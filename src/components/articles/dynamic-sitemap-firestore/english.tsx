import React from 'react';
import ReactGist from 'react-gist';
import { Anchor } from '../anchor';
import { ArticleContent } from '../article-data';
import { ArticleId } from '../article-id';
import { ArticleImage } from '../article-image';
import { InlineSnippet } from '../inline-snippet';

export const english: ArticleContent = {
    title: 'Maintaining a sitemap based on user generated content',
    description: 'How to maintain a sitemap that includes user generated content',
    shareSentence: 'Here is how to efficiently index user generated content into your sitemap',
    introduction: (
        <p>
            Generating a sitemap for a web app can be trivial (i.e. using free online tools such as{' '}
            <Anchor url="https://xml-sitemaps.com">xml-sitemaps.com</Anchor>). Things get a bit more
            complicated when the content we need to index in the sitemap is generated by the users
            of the web app. Here is how to efficiently build and maintain a dynamic sitemap.
        </p>
    ),
    body: (
        <React.Fragment>
            <ArticleImage
                articleId={ArticleId.dynamicSitemap}
                alt="Abstract representation of a website's sitemap"
                className="image-600"
                filename="indexing.jpg"
            />
            <p>
                The first intuitive option that might come to mind is to have an endpoint that
                generates the dynamic sitemap on demand. This might work for small applications, but
                it becomes too slow when the amount of URLs to index grows beyond a certain limit.
                Additionally we are consuming database resources that will either drain the web app
                or generate additional costs.
            </p>
            <p>
                The sitemap is meant to be an XML and there is nothing wrong with that. The only
                particularity about the sitemap containing dynamic content is that we will need to
                periodically update it. And, because we want to do that without having to deploy new
                code, we will want that file not to be part of the web app's static assets.
            </p>
            <p>
                A good place to store a file that our web app wants to read and modify is a cloud
                storage bucket (e.g. GCP buckets or S3 buckets). We can either create the file
                manually or support the scenario when the file is not present via code. Here I'm
                opting for the first option. Once created, we will read such file every time we need
                to serve the sitemap (via a <InlineSnippet>/sitemap.xml</InlineSnippet> endpoint)
                and return its contents. Here is an example using{' '}
                <Anchor url="https://www.npmjs.com/package/firebase-admin">firebase-admin</Anchor>{' '}
                and{' '}
                <Anchor url="https://www.npmjs.com/package/firebase-functions">
                    firebase-functions
                </Anchor>
                .
            </p>
            <ArticleImage
                articleId={ArticleId.dynamicSitemap}
                filename="gcp-storage-bucket.png"
                footer="Storage bucket view in Google Cloud Platform"
            />
            <ReactGist id="22fc692aa301fad285e013b3927a24cc" />
            <p>
                The challenging part in this approach is deciding when and how to update the file
                contents. It can be tempting to update the file in real time every time users create
                or delete a resource, so the sitemap is always up-to-date. Chances are however that
                users will create content concurrently and we don't want to risk parallel requests
                accessing the file and overwriting the contents at the same time. It would be more
                cautious to allow the sitemap to go a few hours out-of-date and to update it
                periodically via a scheduled job.
            </p>
            <p>
                Another consideration is whether the job should recompute the entire file content or
                make incremental updates to the existing file content. While the first option sounds
                simpler it will also consume more resources. If we are using a cloud-hosted database
                (e.g. Firestore) this will substantially increase the costs of running the web app
                (see this{' '}
                <Anchor url="https://stackoverflow.com/questions/66066333/firebase-functions-hosting-rewrite-to-dynamically-generate-sitemap-xml-with-mor">
                    Stack Overflow post
                </Anchor>
                ). Incremental updates to the file are a bit more tricky but they will pay off. In
                essence we need to:
            </p>
            <ul>
                <li>
                    <b>Flag new resources</b> after they are created so the job can identify the new
                    URLs that must be <b>added</b> to the sitemap.
                </li>
                <li>
                    <b>Track resource deletions</b> so the job can identify the URLs that must be{' '}
                    <b>removed</b> from the sitemap.
                </li>
            </ul>
            <p>
                The job will then obtain the list of URLs that must be added/removed, read the
                contents of the file, update it with the corresponding URL changes and write the
                file back to the storage bucket. The implementation will depend largely on the
                server architecture. Here is an example using Firestore and Firebase functions
                assuming that:
            </p>
            <ul>
                <li>
                    Each resource contains a property (i.e. <InlineSnippet>created</InlineSnippet>)
                    with its creation timestamp. To find out which resources need to be added to the
                    sitemap we will filter on that property for values between now and the last time
                    the job run.
                </li>
                <li>
                    We are using the <InlineSnippet>onDocumentDeleted</InlineSnippet> Firebase
                    trigger to add the corresponding document ID to another Firestore collection
                    (i.e. <InlineSnippet>sitemapDeletions</InlineSnippet>) every time a resource is
                    deleted.
                </li>
                <li>
                    The URLs can be built from each resource ID without any logic. If we wanted to
                    support different types of dynamic URLs, we would have to store additional
                    metadata in the <InlineSnippet>sitemapDeletions</InlineSnippet> collection.
                </li>
                <li>
                    We have two functions (i.e. <InlineSnippet>getNewResourceIds</InlineSnippet> and{' '}
                    <InlineSnippet>getDeletedResourceIds</InlineSnippet>) that retrieve the complete
                    list of IDs that must be added/removed to the sitemap. Such functions crawl the
                    Firestore collections and build a plain list of strings.
                </li>
            </ul>
            <ReactGist id="4762368d88693b8991df334e39482de2" />
            <p>
                <i>
                    Similarly to the <InlineSnippet>sitemapDeletions</InlineSnippet> collection, we
                    could define a <InlineSnippet>sitemapAdditions</InlineSnippet> collection and
                    use the <InlineSnippet>onDocumentCreated</InlineSnippet> trigger to add URLs
                    every time a new resource is created. Note however that this would mean
                    additional write operations to remove the IDs from the collection after the job
                    has updated the file. Symmetric approach but higher costs.
                </i>
            </p>
            <p>
                Once deployed the job will run every midnight, looking for changes in resources and
                updating the sitemap accordingly when needed. Happy coding!
            </p>
        </React.Fragment>
    )
};
