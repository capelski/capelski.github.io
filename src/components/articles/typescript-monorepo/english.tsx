import React from 'react';
import { Anchor } from '../anchor';
import { ArticleContent } from '../article-data';
import { ArticleId } from '../article-id';
import { ArticleImage } from '../article-image';
import { BlockSnippet } from '../block-snippet';
import { InlineSnippet } from '../inline-snippet';
import { Spaces } from '../spaces';
import { DirectoryView } from '../directory-view';

export const english: ArticleContent = {
    title: 'Client/Server code sharing in Typescript monorepos',
    description: 'How to share code between client and server in Typescript monorepos',
    shareSentence: 'Time to get rid of the duplicated code in your Typescript monorepo!',
    introduction: (
        <p>
            Writing a web server on node.js means using the same programming languages on both sides
            of a web app. Which should allow for sharing a good amount of code between the client
            and the server apps. Which should be easy when both apps are part of the same monorepo.
            Then, why do things get complicated when we add Typescript to the mix?
        </p>
    ),
    body: (
        <React.Fragment>
            <h3>The "replication" problem</h3>
            <p>
                In Javascript monorepos, node.js runs the very same files where the source code is
                written. Therefore, we can we can easily extract the duplicated code to shared files
                and require them using relative paths üëç We will need to decide how we ship the
                shared files to production environments but that's a separate story.
            </p>
            <p>
                In Typescript monorepos however, node.js runs a set of transpiled files, which are
                usually in a different location from the source code files (e.g. a{' '}
                <InlineSnippet>lib</InlineSnippet> or <InlineSnippet>dist</InlineSnippet> folder).
                This set of transpiled files is generated by turning the Typescript files in the
                source folder into Javascript files in the distribution folder, replicating the same
                folder structure. For example:
            </p>
            <BlockSnippet>
                <DirectoryView
                    structure={{
                        public: {},
                        src: {
                            utils: { 'arrays.ts': true },
                            "main.ts\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# import a from './utils/array';": true,
                            "express.ts\u00A0\u00A0\u00A0\u00A0\u00A0# express.static(path.join(__dirname, '..', 'public'));": true
                        },
                        dist: {
                            utils: { 'arrays.js': true },
                            "main.js\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# const a = require('./utils/array'); ‚úÖ": true,
                            "express.js\u00A0\u00A0\u00A0\u00A0\u00A0# express.static(path.join(__dirname, '..', 'public')); ‚úÖ": true
                        },
                        'package.json\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# "npm run start": "node dist/main.js" ‚úÖ': true,
                        'tsconfig.json': true
                    }}
                />
            </BlockSnippet>
            <p>
                <i>
                    It is possible to keep the transpiled files in the same relative location as the
                    source files, but we usually compile them to a separate location for easier
                    manipulation of the distribution files.
                </i>
            </p>
            <p>
                This "replication" strategy is meant so that Typescript can guarantee, for each
                relative import/require statement, that the corresponding file will be available at
                the same relative path. Note that the "replication" strategy hereby defines an
                important property of Typescript: import/require paths are never modified during
                transpilation.
            </p>
            <p>
                In the example above, the{' '}
                <InlineSnippet>import a from './utils/array';</InlineSnippet> import statement in{' '}
                <InlineSnippet>main.ts</InlineSnippet> will be transpiled into{' '}
                <InlineSnippet>const a = require('./utils/array');</InlineSnippet> in{' '}
                <InlineSnippet>main.js</InlineSnippet>. Because the folder structure is the same in
                both cases, the relative paths are correct for both Typescript and node.js. So far
                so good.
            </p>
            <p>
                The "replication" strategy however has unexpected side effects when importing code,
                via relative paths, from outside the Typescript project{' '}
                <Anchor url="https://www.typescriptlang.org/tsconfig#rootDir">root folder</Anchor>{' '}
                (usually the folder where <InlineSnippet>tsconfig.json</InlineSnippet> is located).
                In those cases, the only way to guarantee the relative paths after transpiling is to
                include the folders outside the project in the structure of the distribution folder.
                For example:
            </p>
            <BlockSnippet>
                <DirectoryView
                    structure={{
                        utils: {
                            src: {
                                'arrays.ts': true
                            }
                        },
                        server: {
                            public: {},
                            src: {
                                "main.ts\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# import a from '../../utils/src/arrays';": true,
                                "express.ts\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# express.static(path.join(__dirname, '..', 'public'));": true
                            },
                            dist: {
                                utils: {
                                    src: {
                                        'arrays.js': true
                                    }
                                },
                                server: {
                                    src: {
                                        "main.js\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# const a = require('../../utils/src/arrays'); ‚úÖ": true,
                                        "express.js\u00A0\u00A0\u00A0\u00A0\u00A0# express.static(path.join(__dirname, '..', 'public')); ‚ùå": true
                                    }
                                }
                            },
                            'package.json\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0# "npm run start": "node dist/main.js" ‚ùå': true,
                            'tsconfig.json': true
                        }
                    }}
                />
            </BlockSnippet>
            <p>
                So, in this second example, the import statement{' '}
                <InlineSnippet>import a from '../../utils/src/arrays';</InlineSnippet> in{' '}
                <InlineSnippet>main.ts</InlineSnippet> becomes{' '}
                <InlineSnippet>const a = require('../../utils/src/arrays');</InlineSnippet> in{' '}
                <InlineSnippet>main.js</InlineSnippet>. Still correct for both Typescript and
                node.js, because the structure of the distribution folder has been specifically
                generated to support the import relative paths.
            </p>
            <p>
                However paths that fall outside Typescript's scope (the start script in the{' '}
                <InlineSnippet>package.json</InlineSnippet> and the path to the{' '}
                <InlineSnippet>public</InlineSnippet> folder where the static assets are stored) are
                not aware of the change in the folder structure and will lead into runtime errors
                due to files not existing at the expected locations. That's not good. And that's
                exactly what I call the "replication" problem.
            </p>
            <p>
                <i>
                    Note that Typescript's "replication" strategy also applies to client side
                    projects. It usually doesn't introduce problems however, because usually the
                    client side files are bundled together in a single file. That single "bundle"
                    file contains all the code, so it doesn't need to import/require any other file
                    via relative paths.
                </i>
            </p>
            <h3>A sample app</h3>
            <p>
                Before looking at different ways to solve the "replication" problem, let's create a
                sample Typescript web app to better illustrate each different approach that we can
                use. I will call such web app{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo">
                    <b>Weather Now</b>
                </Anchor>
                :
            </p>
            <ul>
                <li>
                    On one side we have a React UI (i.e.{' '}
                    <InlineSnippet>weather-client</InlineSnippet>) that fetches weather data for a
                    given city from a web API and displays it in a simple layout.
                </li>
                <li>
                    On the other side we have an <b>Express web API</b> (i.e.{' '}
                    <InlineSnippet>wether-server</InlineSnippet>) with a single endpoint that
                    returns weather data (i.e. <InlineSnippet>/api/weather</InlineSnippet>). It also
                    serves the static UI files in the root url.
                </li>
            </ul>
            <ArticleImage
                articleId={ArticleId.typescriptMonorepo}
                filename="weather-now-ui.png"
                footer="Weather Now UI"
            />
            <p>
                And just like most modern web applications it contains two types of duplicate code:
            </p>
            <ul>
                <li>
                    <b>Validation logic</b>. <InlineSnippet>validateCityName</InlineSnippet> is a
                    function which validates that a city name has been provided. It's executed on
                    both the client side, to improve the error detection user experience, and on the
                    server side, to protect ourselves from API faulty calls.
                </li>
                <li>
                    <b>Data models</b>. The same <InlineSnippet>Validation</InlineSnippet>,{' '}
                    <InlineSnippet>Weather</InlineSnippet> and{' '}
                    <InlineSnippet>WeatherIcons</InlineSnippet> types are used in both client and
                    server side. Since we deal with the same data types on both ends, it's only
                    logic to define symmetric data models.
                </li>
            </ul>
            <ArticleImage
                articleId={ArticleId.typescriptMonorepo}
                filename="duplicated-code.png"
                footer="Sample duplicated code in Weather Now"
            />
            <p>
                Now let's introduce the "replication" problem. By extracting that duplicated code
                into a common folder (e.g. <InlineSnippet>weather-common</InlineSnippet>) and
                requiring it through relative path imports, we can observer how the structure of
                distribution folder changes after transpiling the code (see{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/base-code-extraction">
                    base-code-extraction
                </Anchor>{' '}
                branch).
            </p>
            <ArticleImage
                articleId={ArticleId.typescriptMonorepo}
                filename="base-code-extraction.png"
                footer="Extraction of duplicated code to common folder"
            />
            <p>
                The code extraction leads to the npm start script failing and, if we run the
                transpiled file in the new file path (i.e.{' '}
                <InlineSnippet>
                    node weather-server/distribution/weather-server/source/index.js
                </InlineSnippet>
                ), the express server fails to serve the static assets. Great, we have introduced
                the "replication" problem. Now let's fix it using different solutions üõ†Ô∏è
            </p>
            <h3 id="relative-path-fixes">Solution 1. Relative paths fixes</h3>
            <p>
                The quick and dirty approach to get things working again. We just need to adapt all
                paths and references outside Typescript import statements to match the changes in
                the distribution folder. Doable, but can be challenging on large projects, specially
                because some errors will only appear on runtime.
            </p>
            <p>
                Branch:{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/1-path-fixes">
                    1-path-fixes
                </Anchor>
                .
            </p>
            <p>Implementation:</p>
            <ul>
                <li>
                    Change the references to compiled files in
                    <InlineSnippet>package.json</InlineSnippet>: the{' '}
                    <InlineSnippet>main</InlineSnippet> property and the{' '}
                    <InlineSnippet>start</InlineSnippet> npm script.
                </li>
                <li>
                    Change the path to the static assets folder. Because we want to keep the ability
                    to run the code without compiling we will need to define this path based on the
                    "execution mode". This means, for example, introducing an environment variable
                    (e.g. <InlineSnippet>process.env.NODEMON</InlineSnippet>) to distinguish between
                    node and nodemon/ts-node executions.
                </li>
            </ul>
            <ArticleImage
                articleId={ArticleId.typescriptMonorepo}
                filename="relative-path-fixes.png"
                footer="Adaptations for the structure of the distribution folder"
            />
            <h3 id="common-npm-project">Solution 2. Common npm project</h3>
            <p>
                By turning the common folder into an npm project itself, Typescript assumes that the
                compiled files will exist in the relative paths and it will stop including the
                outside folders in the distribution folder üí™ Note that as a result of turning the
                common folder into a separate npm project:
            </p>
            <ul>
                <li>
                    We are introducing a "build dependency". We will need to compile the common
                    project separately before compiling the projects that depend on it.
                </li>
                <li>
                    <p>
                        Typescript looses access to the types definitions. We will need to generate
                        type declaration files for the common project (i.e. setting the{' '}
                        <InlineSnippet>declaration</InlineSnippet> property to true in{' '}
                        <InlineSnippet>tsconfig.json</InlineSnippet>) and let Typescript know where
                        to locate those files (i.e. setting the <InlineSnippet>types</InlineSnippet>{' '}
                        property in the common <InlineSnippet>package.json</InlineSnippet>) in order
                        to compile the dependent projects.
                    </p>
                    <p>
                        Note that, at least in VSCode, the type definitions will cause the IDE
                        symbols navigation to resolve to the declaration files instead of the source
                        code. Unfortunately we can't fix this issue when using relative path
                        imports.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="common-npm-project-types-resolution.png"
                        footer="VSCode types definition resolution through declaration files"
                    />
                </li>
                <li>
                    Hot reloading will no longer detect changes happening outside the project source
                    folder. We will need to compile the common project in watch mode as well as
                    using nodemon (or a similar tool) to watch for changes in the common project's
                    source folder.
                </li>
            </ul>
            <p>
                Branch:{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/2-npm-project">
                    2-npm-project
                </Anchor>
                .
            </p>
            <p>Implementation:</p>
            <ul>
                <li>
                    <p>
                        Move the duplicate code to a source subfolder in the common folder and add a{' '}
                        <InlineSnippet>tsconfig.json</InlineSnippet> file to set up the Typescript
                        compilation. Set the <InlineSnippet>declaration</InlineSnippet> property to
                        true, in order to generate type declaration files.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="common-npm-project.png"
                        footer="Extraction of duplicated code to common npm project"
                    />
                </li>
                <li>
                    <p>
                        Add a<InlineSnippet>package.json</InlineSnippet> file to the common folder.
                        Define an npm script to compile the Typescript code (e.g.{' '}
                        <InlineSnippet>build</InlineSnippet>). Set the{' '}
                        <InlineSnippet>types</InlineSnippet> property, so that Typescript knows
                        where to locate the type declaration files.
                    </p>
                </li>
                <li>
                    <p>
                        Change the compilation npm scripts in dependant projects to compile the
                        common project as well.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="common-npm-project-build-dependency.png"
                        footer="Modifications to build npm script to compile common project"
                    />
                </li>
                <li>
                    <p>
                        To maintain the hot reloading in dependent projects, change the development
                        npm scripts to compile the common project in watch mode and set nodemon to
                        watch for changes in the common project's source folder, via{' '}
                        <InlineSnippet>nodemon.json</InlineSnippet>.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="common-npm-project-nodemon.png"
                        footer="Hot reloading necessary changes after extracting duplicated code"
                    />
                </li>
            </ul>
            <h3 id="local-dependencies">Solution 3. Local dependencies</h3>
            <p>
                Building on top of the "Common npm project" approach we can use npm local
                dependencies (
                <Anchor url="https://docs.npmjs.com/cli/v8/commands/npm-install">
                    natively supported
                </Anchor>{' '}
                since npm 2.0) to install the common project as a dependency of other npm projects
                that import code from it, letting node find the common code via{' '}
                <InlineSnippet>node_modules</InlineSnippet>. When using local dependencies:
            </p>
            <ul>
                <li>
                    npm creates a symbolic link to the local dependency project inside each
                    dependent project's <InlineSnippet>node_modules</InlineSnippet> folder.
                </li>
                <li>
                    <p>
                        We no longer need relative paths to import code from outside the project; we
                        can use the common project name instead. We have greater freedom to refactor
                        the common project, without having to reflect the changes in any of the
                        import statements of the dependent projects.
                    </p>
                    <p>
                        Importing via project name also allows us to restore the IDE symbols
                        navigation (at least, in VSCode) that we lost when extracting the code into
                        a separate npm project. It is done via the{' '}
                        <Anchor url="https://www.typescriptlang.org/tsconfig#paths">paths</Anchor>{' '}
                        property in <InlineSnippet>tsconfig.json</InlineSnippet>.
                    </p>
                </li>
                <li>
                    <p>
                        We introduce a potential drawback: not being able to install public packages
                        with the same name as the local dependencies. For example, naming a project{' '}
                        <InlineSnippet>common</InlineSnippet> would prevent us from installing the{' '}
                        <Anchor url="https://www.npmjs.com/package/common">common</Anchor> package
                        from the npm registry.
                    </p>
                    <p>
                        A convenient way of working around these conflicts is to <b>namespace</b>{' '}
                        the packages. In fact, you might have noticed that some popular packages use
                        the <InlineSnippet>@organization/package</InlineSnippet> format on their
                        names: <InlineSnippet>@types/node</InlineSnippet>,{' '}
                        <InlineSnippet>@react-native-community/slider</InlineSnippet>,{' '}
                        <InlineSnippet>@angular/core</InlineSnippet>, etc. By using that convention
                        is easier to avoid name conflicts, since your local dependencies will have
                        very specific names.
                    </p>
                </li>
            </ul>
            <p>
                Branch:{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/3-local-dependency">
                    3-local-dependency
                </Anchor>{' '}
                (or{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/3-local-dependency-namespace">
                    3-local-dependency-namespace
                </Anchor>{' '}
                for namespaced projects).
            </p>
            <p>Implementation:</p>
            <ul>
                <li>
                    <p>
                        Install the common project as a local dependency in all the projects that
                        are importing code from it, using the common project relative path:
                    </p>
                    <BlockSnippet>
                        cd weather-client
                        <br />
                        npm install --save ../weather-common
                        <br />
                        cd ../weather-server
                        <br />
                        npm install --save ../weather-common
                    </BlockSnippet>
                    <p>
                        This will register the local dependency in both{' '}
                        <InlineSnippet>package.json</InlineSnippet> and{' '}
                        <InlineSnippet>package-lock.json</InlineSnippet> in the dependent projects.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="local-dependency-symbolic-links.png"
                        footer="node.js generated symbolic links"
                    />
                </li>
                <li>
                    <p>
                        Replace all the relative path imports with external dependency imports,
                        using the name of the common project.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="local-dependency-import.png"
                        footer="npm local dependency import"
                    />
                </li>
                <li>
                    <p>
                        To restore the IDE symbols navigation, set the Typescript{' '}
                        <Anchor url="https://www.typescriptlang.org/tsconfig#paths">paths</Anchor>{' '}
                        property:
                    </p>
                    <BlockSnippet>
                        {'{'}
                        <br />
                        <Spaces number={2} />
                        "compilerOptions": {'{'}
                        <br />
                        <Spaces number={4} />
                        "paths": {'{'}
                        <br />
                        <Spaces number={6} />
                        "weather-common": ["./weather-common/source"]
                        <br />
                        <Spaces number={4} />
                        {'}'}
                        <br />
                        <Spaces number={2} />
                        {'}'},<br />
                        <Spaces number={2} />
                        "extends": "./tsconfig.base.json"
                        <br />
                        {'}'}
                    </BlockSnippet>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="local-dependency-types-resolution.png"
                        footer="VSCode types definition resolution through Typescript paths"
                    />
                    <p>
                        <i>
                            Note that using Typescript paths to resolve the relative path imports
                            without registering the local npm dependencies will result in runtime
                            errors since, as previously mentioned, Typescript does not modify the
                            imports path on compilation.
                        </i>
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="wrong-ts-paths-resolution.png"
                        footer="Wrong usage of Typescript paths"
                    />
                </li>
            </ul>
            <h3 id="workspaces">Solution 4. Workspaces</h3>
            <p>
                Building on top of the "Common npm project" approach we can use{' '}
                <Anchor url="https://docs.npmjs.com/cli/v7/using-npm/workspaces">
                    npm workspaces
                </Anchor>{' '}
                (introduced in npm 7.0) to simplify the management of the different projects in the
                monorepo. When using workspaces:
            </p>
            <ul>
                <li>
                    All dependencies are installed in the root folder's{' '}
                    <InlineSnippet>node_modules</InlineSnippet>, removing the need for each project
                    folder to install its own dependencies. As a result, no{' '}
                    <InlineSnippet>package-lock.json</InlineSnippet> files are needed in the project
                    folders.
                </li>
                <li>
                    Just like in the "Local dependencies" approach, we can use npm local
                    dependencies to install the common project as a dependency of other npm projects
                    that import code from it. Note that this time{' '}
                    <b>the local dependency is managed from the root repository</b>, so relatives
                    paths and symbolic links change slightly, but the rest of benefits from local
                    dependencies are kept just the same.
                </li>
                <li>
                    <p>
                        npm scripts defined in nested projects can be run from the root folder,
                        using the <InlineSnippet>-w</InlineSnippet> or{' '}
                        <InlineSnippet>-ws</InlineSnippet> arguments, which allows removing "soft
                        link" npm scripts.
                    </p>
                    <p>
                        <i>
                            Because, without workspaces, npm doesn't detect scripts defined in
                            nested projects, a common way to run nested scripts from the root folder
                            is to create additional scripts in the root package.json which change
                            the folder (thus the "soft link" term) and then run the corresponding
                            npm script from a nested package.json.
                        </i>
                    </p>
                </li>
            </ul>
            <p>
                Branch:{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces">
                    4-npm-workspaces
                </Anchor>{' '}
                (or{' '}
                <Anchor url="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces-namespace">
                    4-npm-workspaces-namespace
                </Anchor>{' '}
                for namespaced projects).
            </p>
            <p>Implementation:</p>
            <ul>
                <li>
                    <p>
                        Move the different projects into a specific folder (e.g.{' '}
                        <InlineSnippet>projects</InlineSnippet>) and specify that folder through the{' '}
                        <InlineSnippet>workspaces</InlineSnippet> property in the root{' '}
                        <InlineSnippet>package.json</InlineSnippet> (e.g.{' '}
                        <InlineSnippet>["./projects/*"]</InlineSnippet>).
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="npm-workspaces.png"
                        footer="Enabling npm workspaces in package.json"
                    />
                </li>
                <li>
                    Remove the <InlineSnippet>package-lock.json</InlineSnippet> file and the{' '}
                    <InlineSnippet>node_modules</InlineSnippet> folder in each project.
                </li>
                <li>
                    <p>
                        If you have installed local dependencies in any of your projects, you will
                        need to remove them for now, as the relative paths will change when using
                        workspaces. You can later re-install them using the{' '}
                        <InlineSnippet>-w</InlineSnippet> argument (see below). Failing to do so can
                        lead to the following error:
                    </p>
                    <BlockSnippet>
                        npm ERR! Cannot set properties of null (setting 'dev')
                        <br />
                        <br />
                        npm ERR! A complete log of this run can be found in:
                        <br />
                        npm ERR
                        <Spaces number={5} />
                        /.../.npm/_logs/2022-05-30T05_57_51_827Z-debug.log
                        <br />
                    </BlockSnippet>
                </li>
                <li>
                    Remove the <InlineSnippet>node_modules</InlineSnippet> folder in the root folder
                    and re-install npm dependencies from the root folder. This will update the{' '}
                    <InlineSnippet>package-lock.json</InlineSnippet> as well, since npm workspaces
                    come with an additional set of dependencies (e.g.{' '}
                    <InlineSnippet>@nodelib/fs.scandir</InlineSnippet>).
                </li>
                <li>
                    <p>
                        Install the common project as a local dependency in all the projects that
                        import code from it, using the common project relative path and the{' '}
                        <InlineSnippet>-w</InlineSnippet> (or{' '}
                        <InlineSnippet>--workspace</InlineSnippet>) argument to specify the target
                        project:
                    </p>
                    <BlockSnippet>
                        npm install --save ./projects/weather-common -w weather-client
                        <br />
                        npm install --save ./projects/weather-common -w weather-server
                    </BlockSnippet>
                    <p>
                        This will register the local dependency in the root{' '}
                        <InlineSnippet>package.json</InlineSnippet> and{' '}
                        <InlineSnippet>package-lock.json</InlineSnippet>, as well as in the
                        corresponding project's <InlineSnippet>package.json</InlineSnippet>.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="npm-workspaces-symbolic-links.png"
                        footer="node.js generated symbolic links, through workspaces"
                    />
                </li>
                <li>
                    <p>
                        Replace all the relative path imports with external dependency imports,
                        using the name of the common project.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="npm-workspaces-import.png"
                        footer="npm local dependency import, through workspaces"
                    />
                </li>
                <li>
                    <p>
                        To restore the IDE symbols navigation, set the Typescript{' '}
                        <Anchor url="https://www.typescriptlang.org/tsconfig#paths">paths</Anchor>{' '}
                        property:
                    </p>
                    <BlockSnippet>
                        {'{'}
                        <br />
                        <Spaces number={2} />
                        "compilerOptions": {'{'}
                        <br />
                        <Spaces number={4} />
                        "paths": {'{'}
                        <br />
                        <Spaces number={6} />
                        "weather-common": ["./projects/weather-common/source"]
                        <br />
                        <Spaces number={4} />
                        {'}'}
                        <br />
                        <Spaces number={2} />
                        {'}'},<br />
                        <Spaces number={2} />
                        "extends": "./tsconfig.base.json"
                        <br />
                        {'}'}
                    </BlockSnippet>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="npm-workspaces-types-resolution.png"
                        footer="VSCode types definition resolution through Typescript paths"
                    />
                </li>
                <li>
                    <p>
                        To remove "soft link" npm scripts, replace the{' '}
                        <InlineSnippet>cd</InlineSnippet> instructions in the root{' '}
                        <InlineSnippet>package.json</InlineSnippet> npm scripts with the
                        corresponding <InlineSnippet>-w</InlineSnippet> or{' '}
                        <InlineSnippet>-ws</InlineSnippet> argument.
                    </p>
                    <ArticleImage
                        articleId={ArticleId.typescriptMonorepo}
                        filename="npm-workspaces-scripts.png"
                        footer="Simplification of root folder npm scripts through npm workspaces"
                    />
                </li>
            </ul>
            <h3>Conclusion</h3>
            <p>
                Quoting the popular reference to feline taxidermy, "there is more than one way to
                skin a cat". Each described approach will help you preventing the "replication"
                problem: the more implementation effort, the more advantages you get. Give it try
                and decide which one works better for you. Happy coding!
            </p>
        </React.Fragment>
    )
};
