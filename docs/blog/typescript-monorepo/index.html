<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>Client/Server code sharing in Typescript monorepos | Carles Capellas</title><meta name="description" content="How to share code between client and server in Typescript monorepos" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="Client/Server code sharing in Typescript monorepos" data-react-helmet="true"><meta property="og:description" content="How to share code between client and server in Typescript monorepos" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/typescript-monorepo" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/typescript-monorepo/weather-now-ui.png" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article typescript-monorepo" lang="en"><div class="article-info"><h2 class="article-title">Client/Server code sharing in Typescript monorepos</h2><div class="article-details"><span class="article-date">📅 2022-06-25</span><span class="article-duration">🕐 11 mins</span><span class="article-language selected-language">🌎 en</span></div></div><div class="article-body"><p>With the popularization of node.js since 10+ years ago, it's becoming more and more usual to find the same programming language in both sides of web applications. Using node.js in the server side allows for re-using a good amount of logic but, how can we effectively share code between client and server in Typescript monorepos? Let's have a look at different alternatives.</p><p>Most modern web applications are characterized by the following two traits when it comes to code repetition:</p><ul><li>The same <b>validation logic</b> is executed on both client and server side. On the client side, to detect validation errors without having to communicate with the server, and on the server side, to protect ourselves from API faulty calls.</li><li>Very similar <b>data models</b> are used in both client and server side. Since we deal with the same application data on both ends, it's only logic to define symmetric data models.</li></ul><p>In node.js monorepos we can easily extract the duplicated code away and require it using relative paths. But the extraction comes with some challenges when Typescript is in the mix. Let's use a sample Typescript web app to better illustrate those challenges and how to resolve them effectively. We can call it <b>Weather Now</b>.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/weather-now-ui.png" alt="Weather Now UI"><p class="article-image-footer">Weather Now UI</p></div><p>On one hand we have a React UI (i.e. <span class="article-inline-snippet">weather-client</span>) that fetches weather data for a given city from a web API and displays it in a simple layout. On the other hand we have an <b>Express web API</b> (i.e. <span class="article-inline-snippet">wether-server</span>) with a single endpoint that returns weather data (i.e. <span class="article-inline-snippet">/api/weather</span>) and serves the static React UI files in the root url.</p><p>And, to fit the purpose of this article, the <a href="https://github.com/capelski/weather-monorepo" target="_blank">monorepo</a> sure has some duplicated code: <span class="article-inline-snippet">validateCityName</span>, the function which <b>validates</b> that a city name has been provided, and the <span class="article-inline-snippet">Validation</span>, <span class="article-inline-snippet">Weather</span> and <span class="article-inline-snippet">WeatherIcons</span> <b>types</b>.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/duplicated-code.png" alt="Sample duplicated code in Weather Now"><p class="article-image-footer">Sample duplicated code in Weather Now</p></div><p>Now that we have a concrete example, let's proceed to extract that duplicated code into a common folder (e.g. <span class="article-inline-snippet">weather-common</span>) and require it through relative path imports (see <a href="https://github.com/capelski/weather-monorepo/tree/base-code-extraction" target="_blank">base-code-extraction</a> branch).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/base-code-extraction.png" alt="Extraction of duplicated code to common folder"><p class="article-image-footer">Extraction of duplicated code to common folder</p></div><p>Here is where the challenges start: Typescript does compile successfully but node fails to start the server.</p><div class="article-block-snippet">$ npm run start:server<br><br>&gt; start:server<br>&gt; cd weather-server &amp;&amp; npm run start<br><br>&gt; start<br>&gt; node distribution/index.js<br><br>internal/modules/cjs/loader.js:905<br><span>&nbsp;&nbsp;</span>throw err;<br><span>&nbsp;&nbsp;</span>^<br><br>Error: Cannot find module '/.../weather-monorepo/weather-server/distribution/index.js'<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>at Function.Module._resolveFilename (internal/modules/cjs/loader.js:902:15)<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>at Function.Module._load (internal/modules/cjs/loader.js:746:27)<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:75:12)<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>at internal/main/run_main_module.js:17:47 {<br><span>&nbsp;&nbsp;</span>code: 'MODULE_NOT_FOUND',<br><span>&nbsp;&nbsp;</span>requireStack: []<br>}</div><p>In Javascript monorepos, where the code files maintain their relative location at runtime, this type of code extraction works straight away. In Typescript repositories however, where the compiled files generally change their location (i.e. the distribution folder), further configuration is necessary to perform the code extraction, since we are now importing code from outside the Typescript <a href="https://www.typescriptlang.org/tsconfig#rootDir" target="_blank">rootDir</a> .</p><p><i>It is possible to keep the compiled files in the same relative location as the Typescript files (i.e. by removing the <span class="article-inline-snippet">outDir</span> property in <span class="article-inline-snippet">tsconfig.json</span>), but we generally want to compile them to a separate location, so we only include the distribution files when deploying the code to production.</i></p><p>Importing code from outside the scope of a Typescript project forces the Typescript compiler to <b>replicate the file system hierarchy inside the distribution folder</b>, so it can guarantee that the referenced files will be compiled and available from within the distribution folder (note that Typescript never changes the relative paths in compiled files). In Weather Now this causes the <span class="article-inline-snippet">index.js</span> server file's location to change, causing the <span class="article-inline-snippet">start</span> npm script to fail.</p><div class="article-block-snippet">.<br>···<br>├─ weather-common<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>utils.ts<br>└─ weather-server<br><span>&nbsp;&nbsp;&nbsp;</span>├─ distribution<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;</span>├─ weather-common<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>utils.js<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;</span>└─ weather-server<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>index.js<br><span>&nbsp;&nbsp;&nbsp;</span>└─ source<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>index.ts<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>package.json<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>tsconfig.server.json<br>···<br>package.json<br>tsconfig.base.json<br></div><p>Fortunately there are several ways of fixing this problem 👍 Let's have a look at different solutions.</p><h3>1. Relative paths fixes</h3><p>The quick and dirty approach to get things working again. We just need to adapt the code to support the changes in the distribution folder. For Weather Now this means changing the references to compiled files in <span class="article-inline-snippet">package.json</span> (i.e. <span class="article-inline-snippet">main</span> and <span class="article-inline-snippet">start</span> npm script) as well as the paths to certain resources in the code files (see <a href="https://github.com/capelski/weather-monorepo/tree/1-path-fixes" target="_blank">1-path-fixes</a> branch).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/relative-path-fixes.png" alt="Adaptations for the new distribution file system hierarchy"><p class="article-image-footer">Adaptations for the new distribution file system hierarchy</p></div><p>Changing those paths might not look like a major deal but it adds unnecessary complexity to our code. Moreover, it forces us to introduce additional logic to, for example, run the code without compiling (e.g. using <span class="article-inline-snippet">nodemon</span> or <span class="article-inline-snippet">ts-node</span>). For Weather Now this means introducing an environment variable and setting the <span class="article-inline-snippet">express.static</span> path dynamically.</p><p>It works, but we can do better. Why changing the code to match the distribution file system hierarchy when we can change the distribution file system hierarchy to match the code?</p><h3>2. common npm project</h3><p>By turning the common folder into an npm project itself, Typescript will expect the compiled files to exist in the referenced paths and it will stop replicating the file system hierarchy inside the distribution folder 💪 Let's go ahead and add both <span class="article-inline-snippet">package.json</span> and <span class="article-inline-snippet">tsconfig.json</span> files to the common folder, move the code files into a <span class="article-inline-snippet">source</span> subfolder and define an npm script to compile the Typescript code (see <a href="https://github.com/capelski/weather-monorepo/tree/2-npm-project" target="_blank">2-npm-project</a> branch).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project.png" alt="Extraction of duplicated code to common npm project"><p class="article-image-footer">Extraction of duplicated code to common npm project</p></div><p>Note that as a result of extracting the code to a separate project:</p><ul><li>We are introducing a build dependency. We will always need to compile the common project separately before compiling the projects that depend on it (i.e. update the <span class="article-inline-snippet">build</span> npm script on the root <span class="article-inline-snippet">package.json</span>).<div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-build-dependency.png" alt="Modifications to build npm script to compile common project"><p class="article-image-footer">Modifications to build npm script to compile common project</p></div></li><li>Typescript looses access to the types definitions. We will need to generate type declaration files for the common project (i.e. setting the <span class="article-inline-snippet">declaration</span> property to true in <span class="article-inline-snippet">tsconfig.json</span>) and let Typescript know where to locate those files (i.e. setting the <span class="article-inline-snippet">types</span> property in the common <span class="article-inline-snippet">package.json</span>).<div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-types-resolution.png" alt="VSCode types definition resolution through declaration files"><p class="article-image-footer">VSCode types definition resolution through declaration files</p></div><i>Generating type declaration files allows Typescript to compile but will as well cause the IDE symbols navigation to go the declaration files instead of the source code. Unfortunately we can't fix this issue when using relative path imports.</i></li><li>Hot reloading will no longer detect changes happening outside the project <span class="article-inline-snippet">source</span> folder. We will need to compile the common project in watch mode as well as tweaking nodemon (through <span class="article-inline-snippet">nodemon.json</span>) to watch for changes in the common project's source folder.</li><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-nodemon.png" alt="Hot reloading necessary changes after extracting duplicated code"><p class="article-image-footer">Hot reloading necessary changes after extracting duplicated code</p></div></ul><p>Now the compiled common code will remain inside the common project, and the distribution folders of the other projects will remain unchanged 🎉 Much better than <i>1. Relative paths fixes</i>, but still can be improved.</p><div class="article-block-snippet">.<br>···<br>├─ weather-common<br>|<span>&nbsp;&nbsp;</span>├─ distribution<br>|<span>&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br>|<span>&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>utils.js<br>|<span>&nbsp;&nbsp;</span>└─ source<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>utils.ts<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>package.json<br>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>tsconfig.common.json<br>└─ weather-server<br><span>&nbsp;&nbsp;&nbsp;</span>├─ distribution<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br><span>&nbsp;&nbsp;&nbsp;</span>|<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>index.js<br><span>&nbsp;&nbsp;&nbsp;</span>└─ source<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>index.ts<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>···<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>package.json<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>tsconfig.server.json<br>···<br>package.json<br>tsconfig.base.json<br></div><h3>3. common npm project + npm local dependencies</h3><p>After turning the common folder into a separate npm project we can use npm local dependencies (<a href="https://docs.npmjs.com/cli/v8/commands/npm-install" target="_blank">natively supported</a> since npm 2.0) to install the common npm project as a dependency of the other npm projects, get rid of the relative paths in the cross-project import statements* and let npm natively resolve the dependency instead.</p><p>All we need to do is install the common project as a local dependency in all the projects that are importing code from it in the following fashion. This will register the local dependency in both <span class="article-inline-snippet">package.json</span> and <span class="article-inline-snippet">package-lock.json</span> in the dependent projects.</p><div class="article-block-snippet">cd weather-client &amp;&amp; npm install --save ../weather-common<br>cd ../weather-server &amp;&amp; npm install --save ../weather-common</div><p>Under the hood npm creates symbolic links to the local dependency folder inside the dependent projects' <span class="article-inline-snippet">node_modules</span> folder:</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-symbolic-links.png" alt="node.js generated symbolic links"><p class="article-image-footer">node.js generated symbolic links</p></div><p>We can now go ahead and replace all the relative path imports with regular npm dependency imports (see <a href="https://github.com/capelski/weather-monorepo/tree/3-local-dependency" target="_blank">3-local-dependency</a> branch, or <a href="https://github.com/capelski/weather-monorepo/tree/3-local-dependency-namespace" target="_blank">3-local-dependency-namespace</a> if you prefer to namespace your packages).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-import.png" alt="npm local dependency import"><p class="article-image-footer">npm local dependency import</p></div><p>Another advantage from this alternative is that it allows us to restore the IDE source code navigation we lost when extracting the duplicated code to a shared folder. We can use the Typescript <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank">paths</a> property to tell the IDE where to look for type definitions. For Weather Now this is:</p><div class="article-block-snippet">{<br><span>&nbsp;&nbsp;</span>"compilerOptions": {<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>"paths": {<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>"weather-common": ["./weather-common/source"]<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br><span>&nbsp;&nbsp;</span>},<br><span>&nbsp;&nbsp;</span>"extends": "./tsconfig.base.json"<br>}</div><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-types-resolution.png" alt="VSCode types definition resolution through Typescript paths"><p class="article-image-footer">VSCode types definition resolution through Typescript paths</p></div><p>Note that using Typescript paths to resolve the relative path imports without registering the local npm dependencies will result in runtime errors since, as previously mentioned, Typescript does not modify the imports path on compilation.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/wrong-ts-paths-resolution.png" alt="Wrong usage of Typescript paths"><p class="article-image-footer">Wrong usage of Typescript paths</p></div><h3>4. common npm project + npm workspaces</h3><p>After turning the common folder into a separate npm project, we can use <a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces" target="_blank">npm workspaces</a> (introduced in npm 7.0) to simplify the management of the different projects in the monorepo. The main advantage of using npm workspaces is being able to run, directly from the root folder, npm scripts defined in the <span class="article-inline-snippet">package.json</span> of any project in the monorepo.</p><p>In order to enable workspaces in an existing npm monorepo we need to move the different projects into a specific folder (e.g. <span class="article-inline-snippet">projects</span>) and specify that folder through the <span class="article-inline-snippet">workspaces</span> property in the root <span class="article-inline-snippet">package.json</span>. npm workspaces come with a set of dependencies so we will need to re-install npm dependencies after updating the <span class="article-inline-snippet">package.json</span>, which will update <span class="article-inline-snippet">package-lock.json</span> as well.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces.png" alt="Enabling npm workspaces in package.json"><p class="article-image-footer">Enabling npm workspaces in package.json</p></div><p>Note that after the re-install, apart from new npm workspaces specific dependencies (e.g. <span class="article-inline-snippet">@nodelib/fs.scandir</span>), the <span class="article-inline-snippet">package-lock.json</span> file will also contain each of the existing projects in the workspace folder as dependencies. Additionally, npm will create symbolic links in the root <span class="article-inline-snippet">node_modules</span> folder.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-symbolic-links.png" alt="node.js generated symbolic links, through workspaces"><p class="article-image-footer">node.js generated symbolic links, through workspaces</p></div><p>We can now install the common project as a local dependency in all the projects that are importing code from it, this time using workspaces (i.e. the <span class="article-inline-snippet">--workspace</span>, or <span class="article-inline-snippet">-w</span>, argument).</p><div class="article-block-snippet">npm install --save ./projects/weather-common -w weather-client<br>npm install --save ./projects/weather-common -w weather-server</div><p>This will register the local dependency in the root <span class="article-inline-snippet">package.json</span> and the dependent project's <span class="article-inline-snippet">package.json</span>. It should update the dependent projects's <span class="article-inline-snippet">package-lock.json</span> as well, but there is currently an npm <a href="https://github.com/npm/cli/issues/3847" target="_blank">known issue</a> which causes the following install command to fail, leaving the file unchanged.</p><div class="article-block-snippet">$ npm install --save ./projects/weather-common -w weather-client<br>npm ERR! Cannot set properties of null (setting 'dev')<br><br>npm ERR! A complete log of this run can be found in:<br>npm ERR<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>/.../.npm/_logs/2022-05-30T05_57_51_827Z-debug.log<br></div><p>Fortunately there is a simple workaround to that issue: re-installing the dependencies of the dependent project (e.g. running an <span class="article-inline-snippet">npm install</span> in the project folder). We can after replace all the relative paths in the cross-project import statements* with regular npm dependency imports (see <a href="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces" target="_blank">4-npm-workspaces</a> branch, or <a href="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces-namespace" target="_blank">4-npm-workspaces-namespace</a> if you prefer to namespace your packages).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-import.png" alt="npm local dependency import, through workspaces"><p class="article-image-footer">npm local dependency import, through workspaces</p></div><p>Just like when using npm local dependencies, we can as well restore the IDE source code navigation we lost when extracting the duplicated code to a shared folder by using Typescript <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank">paths</a> property to tell the IDE where to look for type definitions. For Weather Now this is:</p><div class="article-block-snippet">{<br><span>&nbsp;&nbsp;</span>"compilerOptions": {<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>"paths": {<br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>"weather-common": ["./projects/weather-common/source"]<br><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br><span>&nbsp;&nbsp;</span>},<br><span>&nbsp;&nbsp;</span>"extends": "./tsconfig.base.json"<br>}</div><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-types-resolution.png" alt="VSCode types definition resolution through Typescript paths"><p class="article-image-footer">VSCode types definition resolution through Typescript paths</p></div><p>One more advantage of having npm workspaces in place is that we can simplify, or even remove, the "shortcut" npm scripts. "shortcut" scripts are a common practice in node.js monorepos: since npm doesn't detect scripts defined in "nested" folders, the only way to run "nested" scripts from the root folder is to define additional scripts which change the folder and then run the corresponding npm script:</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/shortcut-npm-scripts.png" alt="Root folder &quot;shortcut&quot; npm scripts"><p class="article-image-footer">Root folder "shortcut" npm scripts</p></div><p>Since we have landed npm workspaces to our monorepo we can replace the <span class="article-inline-snippet">cd</span> instructions in our root <span class="article-inline-snippet">package.json</span> npm scripts with the corresponding <span class="article-inline-snippet">-w</span> argument, slightly speeding up the scripts execution time:</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-scripts.png" alt="Simplification of root folder npm scripts through npm workspaces"><p class="article-image-footer">Simplification of root folder npm scripts through npm workspaces</p></div><p><i>Note that certain npm scripts must remain intact. We need, for example, to build the projects in a certain order (i.e. <span class="article-inline-snippet">weather-common</span> before <span class="article-inline-snippet">weather-server</span>), so using the <span class="article-inline-snippet">--ws</span> (all workspaces) for the <span class="article-inline-snippet">build</span> script could run into compilation errors. Or, trying to use <span class="article-inline-snippet">npm install -ws</span> in the postinstall script would result into an endless install loop (the workspaces arguments only apply on install when adding/updating a dependency), so we need to keep the original postinstall script.</i></p><h3>* What's the fuss with cross-project relative paths?</h3><p>Relative paths in cross-project import statements are not necessarily a problem. The value of replacing them is in making the dependent projects agnostic of the common code file system hierarchy. This way, if we were to make changes in the common npm project, the dependent projects would remain unchanged (as long as the common code API is kept the same).</p><p>Not that, while both <i>3. npm local dependencies</i> and <i>4. npm workspaces</i> allow for relative paths removal, they introduce a potential minor drawback: not being able to install public packages with the same name as the local dependencies. For example, naming a project <span class="article-inline-snippet">common</span> would prevent us from installing the <a href="https://www.npmjs.com/package/common" target="_blank">common</a> package from the npm registry.</p><p>A convenient way of working around these conflicts is to <b>namespace</b> the packages. In fact, you might have noticed that some popular packages use the <span class="article-inline-snippet">@organization/package</span> format on their names: <span class="article-inline-snippet">@types/node</span>, <span class="article-inline-snippet">@react-native-community/slider</span>, <span class="article-inline-snippet">@angular/core</span>, etc. By using that convention is easier to avoid name conflicts, since your local dependencies will have very specific names.</p><p>To namespace your packages you need to:</p> <ul><li>Move the packages to a <span class="article-inline-snippet">@namespace</span> subfolder.</li><li>Update paths to files outside the project folders accordingly (e.g. the <span class="article-inline-snippet">extends</span> property in <span class="article-inline-snippet">tsconfig.json</span> files referencing the root <span class="article-inline-snippet">tsconfig.base.json</span>).</li><li>Update root <span class="article-inline-snippet">package.json</span> npm scripts that contain project paths.</li><li>Modify the <span class="article-inline-snippet">name</span> property in the <span class="article-inline-snippet">package.json</span> file of your npm projects to include the namespace, and update <span class="article-inline-snippet">package-lock.json</span> by running <span class="article-inline-snippet">npm install</span>.</li><li>In case you are renaming a project (e.g. from <span class="article-inline-snippet">weather-common</span> to <span class="article-inline-snippet">@weather/common</span>), you will need to rename the project folder and update the corresponding relative import paths as well as potential npm scripts in the root <span class="article-inline-snippet">package.json</span>.</li></ul><p>See the corresponding example branch in each section for specific implementation details.</p><h3>Conclusions</h3><p>Quoting the popular reference to feline taxidermy, "there is more than one way to skin a cat". The four described approaches will help you removing duplicated code. The more implementation effort, the more advantages you get. Give them a try and decide which one works better for you. Happy coding! ⌨️</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/expo-push-notifications">⬅️ Previous</a><div class="title-preview">First-class push notifications for Expo apps</div></span></div><div class="next-link"></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">⬇️ Blog</a></div></div></div></div></body></html>