<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>Client/Server code sharing in Typescript monorepos | Carles Capellas</title><meta name="description" content="How to share code between client and server in Typescript monorepos" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="Client/Server code sharing in Typescript monorepos" data-react-helmet="true"><meta property="og:description" content="How to share code between client and server in Typescript monorepos" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/typescript-monorepo" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/typescript-monorepo/weather-now-ui.png" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article typescript-monorepo" lang="en"><div class="article-info"><h2 class="article-title">Client/Server code sharing in Typescript monorepos</h2><div class="article-details"><span class="article-date">📅 2022-06-25</span><span class="article-duration">🕐 11 mins</span><span class="article-language selected-language">🌎 en</span></div></div><div class="article-body"><p>Writing a web server on node.js means using the same programming languages on both sides of a web app. Which should allow for sharing a good amount of code between the client and the server apps. Which should be easy when both apps are part of the same monorepo. Then, why do things get complicated when we add Typescript to the mix?</p><h3>The "replication" problem</h3><p>In Javascript monorepos, node.js runs the very same files where the source code is written. Therefore, we can we can easily extract the duplicated code to shared files and require them using relative paths 👍 We will need to decide how we ship the shared files to production environments but that's a <a href="/blog/typescript-monorepo-ii">separate story</a>.</p><p>In Typescript monorepos however, node.js runs a set of transpiled files, which are usually in a different location from the source code files (e.g. a <span class="article-inline-snippet">lib</span> or <span class="article-inline-snippet">dist</span> folder). This set of transpiled files is generated by turning the Typescript files in the source folder into Javascript files in the distribution folder, replicating the same folder structure. For example:</p><div class="article-block-snippet">root<br>📂&nbsp;public<br>📂&nbsp;src<br>|&nbsp;&nbsp;📂&nbsp;utils<br>|&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;arrays.ts<br>|&nbsp;&nbsp;📝&nbsp;main.ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# import a from './utils/array';<br>|&nbsp;&nbsp;📝&nbsp;express.ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# express.static(path.join(__dirname, '..', 'public'));<br>📂&nbsp;dist<br>|&nbsp;&nbsp;📂&nbsp;utils<br>|&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;arrays.js<br>|&nbsp;&nbsp;📝&nbsp;main.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# const a = require('./utils/array'); ✅<br>|&nbsp;&nbsp;📝&nbsp;express.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# express.static(path.join(__dirname, '..', 'public')); ✅<br>📝&nbsp;package.json&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# "npm run start": "node dist/main.js" ✅<br>📝&nbsp;tsconfig.json<br></div><p><i>It is possible to keep the transpiled files in the same relative location as the source files, but we usually compile them to a separate location for easier manipulation of the distribution files.</i></p><p>This "replication" strategy is meant so that Typescript can guarantee, for each relative import/require statement, that the corresponding file will be available at the same relative path. Note that the "replication" strategy hereby defines an important property of Typescript: import/require paths are never modified during transpilation.</p><p>In the example above, the <span class="article-inline-snippet">import a from './utils/array';</span> import statement in <span class="article-inline-snippet">main.ts</span> will be transpiled into <span class="article-inline-snippet">const a = require('./utils/array');</span> in <span class="article-inline-snippet">main.js</span>. Because the folder structure is the same in both cases, the relative paths are correct for both Typescript and node.js. So far so good.</p><p>The "replication" strategy however has unexpected side effects when importing code, via relative paths, from outside the Typescript project <a href="https://www.typescriptlang.org/tsconfig#rootDir" target="_blank">root folder</a> (usually the folder where <span class="article-inline-snippet">tsconfig.json</span> is located). In those cases, the only way to guarantee the relative paths after transpiling is to include the folders outside the project in the structure of the distribution folder. For example:</p><div class="article-block-snippet">root<br>📂&nbsp;utils<br>|&nbsp;&nbsp;📂&nbsp;src<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;arrays.ts<br>📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;📂&nbsp;public<br>&nbsp;&nbsp;&nbsp;📂&nbsp;src<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;main.ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# import a from '../../utils/src/arrays';<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;express.ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# express.static(path.join(__dirname, '..', 'public'));<br>&nbsp;&nbsp;&nbsp;📂&nbsp;dist<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;utils<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;src<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;arrays.js<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📂&nbsp;src<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;main.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# const a = require('../../utils/src/arrays'); ✅<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;express.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# express.static(path.join(__dirname, '..', 'public')); ❌<br>&nbsp;&nbsp;&nbsp;📝&nbsp;package.json&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# "npm run start": "node dist/main.js" ❌<br>&nbsp;&nbsp;&nbsp;📝&nbsp;tsconfig.json<br></div><p>So, in this second example, the import statement <span class="article-inline-snippet">import a from '../../utils/src/arrays';</span> in <span class="article-inline-snippet">main.ts</span> becomes <span class="article-inline-snippet">const a = require('../../utils/src/arrays');</span> in <span class="article-inline-snippet">main.js</span>. Still correct for both Typescript and node.js, because the structure of the distribution folder has been specifically generated to support the import relative paths.</p><p>However paths that fall outside Typescript's scope (the start script in the <span class="article-inline-snippet">package.json</span> and the path to the <span class="article-inline-snippet">public</span> folder where the static assets are stored) are not aware of the change in the folder structure and will lead into runtime errors due to files not existing at the expected locations. That's not good. And that's exactly what I call the "replication" problem.</p><p><i>Note that Typescript's "replication" strategy also applies to client side projects. It usually doesn't introduce problems however, because usually the client side files are bundled together in a single file. That single "bundle" file contains all the code, so it doesn't need to import/require any other file via relative paths.</i></p><h3>A sample app</h3><p>Before looking at different ways to solve the "replication" problem, let's create a sample Typescript web app to better illustrate each different approach that we can use. I will call such web app <a href="https://github.com/capelski/weather-monorepo" target="_blank"><b>Weather Now</b></a>:</p><ul><li>On one side we have a React UI (i.e. <span class="article-inline-snippet">weather-client</span>) that fetches weather data for a given city from a web API and displays it in a simple layout.</li><li>On the other side we have an <b>Express web API</b> (i.e. <span class="article-inline-snippet">wether-server</span>) with a single endpoint that returns weather data (i.e. <span class="article-inline-snippet">/api/weather</span>). It also serves the static UI files in the root url.</li></ul><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/weather-now-ui.png" alt="Weather Now UI"><p class="article-image-footer">Weather Now UI</p></div><p>And just like most modern web applications it contains two types of duplicate code:</p><ul><li><b>Validation logic</b>. <span class="article-inline-snippet">validateCityName</span> is a function which validates that a city name has been provided. It's executed on both the client side, to improve the error detection user experience, and on the server side, to protect ourselves from API faulty calls.</li><li><b>Data models</b>. The same <span class="article-inline-snippet">Validation</span>, <span class="article-inline-snippet">Weather</span> and <span class="article-inline-snippet">WeatherIcons</span> types are used in both client and server side. Since we deal with the same data types on both ends, it's only logic to define symmetric data models.</li></ul><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/duplicated-code.png" alt="Sample duplicated code in Weather Now"><p class="article-image-footer">Sample duplicated code in Weather Now</p></div><p>Now let's introduce the "replication" problem. By extracting that duplicated code into a common folder (e.g. <span class="article-inline-snippet">weather-common</span>) and requiring it through relative path imports, we can observer how the structure of distribution folder changes after transpiling the code (see <a href="https://github.com/capelski/weather-monorepo/tree/base-code-extraction" target="_blank">base-code-extraction</a> branch).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/base-code-extraction.png" alt="Extraction of duplicated code to common folder"><p class="article-image-footer">Extraction of duplicated code to common folder</p></div><p>The code extraction leads to the npm start script failing and, if we run the transpiled file in the new file path (i.e. <span class="article-inline-snippet">node weather-server/distribution/weather-server/source/index.js</span>), the express server fails to serve the static assets. Great, we have introduced the "replication" problem. Now let's fix it using different solutions 🛠️</p><h3 id="relative-path-fixes">Solution 1. Relative paths fixes</h3><p>The quick and dirty approach to get things working again. We just need to adapt all paths and references outside Typescript import statements to match the changes in the distribution folder. Doable, but can be challenging on large projects, specially because some errors will only appear on runtime.</p><p>Branch: <a href="https://github.com/capelski/weather-monorepo/tree/1-path-fixes" target="_blank">1-path-fixes</a>.</p><p>Implementation:</p><ul><li>Change the references to compiled files in <span class="article-inline-snippet">package.json</span>: the <span class="article-inline-snippet">main</span> property and the <span class="article-inline-snippet">start</span> npm script.</li><li>Change the path to the static assets folder. Because we want to keep the ability to run the code without compiling we will need to define this path based on the "execution mode". This means, for example, introducing an environment variable (e.g. <span class="article-inline-snippet">process.env.NODEMON</span>) to distinguish between node and nodemon/ts-node executions.</li></ul><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/relative-path-fixes.png" alt="Adaptations for the structure of the distribution folder"><p class="article-image-footer">Adaptations for the structure of the distribution folder</p></div><h3 id="common-npm-project">Solution 2. Common npm project</h3><p>By turning the common folder into an npm project itself, Typescript assumes that the compiled files will exist in the relative paths and it will stop including the outside folders in the distribution folder 💪 Note that as a result of turning the common folder into a separate npm project:</p><ul><li>We are introducing a "build dependency". We will need to compile the common project separately before compiling the projects that depend on it.</li><li><p>Typescript looses access to the types definitions. We will need to generate type declaration files for the common project (i.e. setting the <span class="article-inline-snippet">declaration</span> property to true in <span class="article-inline-snippet">tsconfig.json</span>) and let Typescript know where to locate those files (i.e. setting the <span class="article-inline-snippet">types</span> property in the common <span class="article-inline-snippet">package.json</span>) in order to compile the dependent projects.</p><p>Note that, at least in VSCode, the type definitions will cause the IDE symbols navigation to resolve to the declaration files instead of the source code. Unfortunately we can't fix this issue when using relative path imports.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-types-resolution.png" alt="VSCode types definition resolution through declaration files"><p class="article-image-footer">VSCode types definition resolution through declaration files</p></div></li><li>Hot reloading will no longer detect changes happening outside the project source folder. We will need to compile the common project in watch mode as well as using nodemon (or a similar tool) to watch for changes in the common project's source folder.</li></ul><p>Branch: <a href="https://github.com/capelski/weather-monorepo/tree/2-npm-project" target="_blank">2-npm-project</a>.</p><p>Implementation:</p><ul><li><p>Move the duplicate code to a source subfolder in the common folder and add a <span class="article-inline-snippet">tsconfig.json</span> file to set up the Typescript compilation. Set the <span class="article-inline-snippet">declaration</span> property to true, in order to generate type declaration files.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project.png" alt="Extraction of duplicated code to common npm project"><p class="article-image-footer">Extraction of duplicated code to common npm project</p></div></li><li><p>Add a <span class="article-inline-snippet">package.json</span> file to the common folder. Define an npm script to compile the Typescript code (e.g. <span class="article-inline-snippet">build</span>). Set the <span class="article-inline-snippet">types</span> property, so that Typescript knows where to locate the type declaration files.</p></li><li><p>Change the compilation npm scripts in dependant projects to compile the common project as well.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-build-dependency.png" alt="Modifications to build npm script to compile common project"><p class="article-image-footer">Modifications to build npm script to compile common project</p></div></li><li><p>To maintain the hot reloading in dependent projects, change the development npm scripts to compile the common project in watch mode and set nodemon to watch for changes in the common project's source folder, via <span class="article-inline-snippet">nodemon.json</span>.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/common-npm-project-nodemon.png" alt="Hot reloading necessary changes after extracting duplicated code"><p class="article-image-footer">Hot reloading necessary changes after extracting duplicated code</p></div></li></ul><h3 id="local-dependencies">Solution 3. Local dependencies</h3><p>Building on top of the "Common npm project" approach we can use npm local dependencies (natively supported since npm 2.0) to install the common project as a dependency of other npm projects that import code from it, letting node find the common code via <span class="article-inline-snippet">node_modules</span>. When using local dependencies:</p><ul><li>npm creates a symbolic link to the local dependency project inside each dependent project's <span class="article-inline-snippet">node_modules</span> folder.</li><li><p>We no longer need relative paths to import code from outside the project; we can use the common project name instead. We have greater freedom to refactor the common project, without having to reflect the changes in any of the import statements of the dependent projects.</p><p>Importing via project name also allows us to restore the IDE symbols navigation (at least, in VSCode) that we lost when extracting the code into a separate npm project. It is done via the <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank">paths</a> property in <span class="article-inline-snippet">tsconfig.json</span>.</p></li><li><p>We introduce a potential drawback: not being able to install public packages with the same name as the local dependencies. For example, naming a project <span class="article-inline-snippet">common</span> would prevent us from installing the <a href="https://www.npmjs.com/package/common" target="_blank">common</a> package from the npm registry.</p><p>A convenient way of working around these conflicts is to <b>namespace</b> the packages. In fact, you might have noticed that some popular packages use the <span class="article-inline-snippet">@organization/package</span> format on their names: <span class="article-inline-snippet">@types/node</span>, <span class="article-inline-snippet">@react-native-community/slider</span>, <span class="article-inline-snippet">@angular/core</span>, etc. By using that convention is easier to avoid name conflicts, since your local dependencies will have very specific names.</p></li></ul><p>Branch: <a href="https://github.com/capelski/weather-monorepo/tree/3-local-dependency" target="_blank">3-local-dependency</a> (or <a href="https://github.com/capelski/weather-monorepo/tree/3-local-dependency-namespace" target="_blank">3-local-dependency-namespace</a> for namespaced projects).</p><p>Implementation:</p><ul><li><p>Install the common project as a local dependency in all the projects that are importing code from it, using the common project relative path:</p><div class="article-block-snippet">cd weather-client<br>npm install --save ../weather-common<br>cd ../weather-server<br>npm install --save ../weather-common</div><p>This will register the local dependency in both <span class="article-inline-snippet">package.json</span> and <span class="article-inline-snippet">package-lock.json</span> in the dependent projects.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-symbolic-links.png" alt="node.js generated symbolic links"><p class="article-image-footer">node.js generated symbolic links</p></div></li><li><p>Replace all the relative path imports with external dependency imports, using the name of the common project.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-import.png" alt="npm local dependency import"><p class="article-image-footer">npm local dependency import</p></div></li><li><p>To restore the IDE symbols navigation, set the Typescript <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank">paths</a> property:</p><div class="article-block-snippet">{<br>&nbsp;&nbsp;&nbsp;"compilerOptions": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"paths": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"weather-common": [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"./weather-common/source"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;"extends": "./tsconfig.base.json"<br>}<br></div><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/local-dependency-types-resolution.png" alt="VSCode types definition resolution through Typescript paths"><p class="article-image-footer">VSCode types definition resolution through Typescript paths</p></div><p><i>Note that using Typescript paths to resolve the relative path imports without registering the local npm dependencies will result in runtime errors since, as previously mentioned, Typescript does not modify the imports path on compilation.</i></p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/wrong-ts-paths-resolution.png" alt="Wrong usage of Typescript paths"><p class="article-image-footer">Wrong usage of Typescript paths</p></div></li></ul><h3 id="workspaces">Solution 4. Workspaces</h3><p>Building on top of the "Common npm project" approach we can use <a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces" target="_blank">npm workspaces</a> (introduced in npm 7.0) to simplify the management of the different projects in the monorepo. When using workspaces:</p><ul><li>All dependencies are installed in the root folder's <span class="article-inline-snippet">node_modules</span>, removing the need for each project folder to install its own dependencies. As a result, no <span class="article-inline-snippet">package-lock.json</span> files are needed in the project folders.</li><li>Just like in the "Local dependencies" approach, we can use npm local dependencies to install the common project as a dependency of other npm projects that import code from it. Note that this time <b>the local dependency is managed from the root repository</b>, so relatives paths and symbolic links change slightly, but the rest of benefits from local dependencies are kept just the same.</li><li><p>npm scripts defined in nested projects can be run from the root folder, using the <span class="article-inline-snippet">-w</span> or <span class="article-inline-snippet">-ws</span> arguments, which allows removing "soft link" npm scripts.</p><p><i>Because, without workspaces, npm doesn't detect scripts defined in nested projects, a common way to run nested scripts from the root folder is to create additional scripts in the root package.json which change the folder (thus the "soft link" term) and then run the corresponding npm script from a nested package.json.</i></p></li></ul><p>Branch: <a href="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces" target="_blank">4-npm-workspaces</a> (or <a href="https://github.com/capelski/weather-monorepo/tree/4-npm-workspaces-namespace" target="_blank">4-npm-workspaces-namespace</a> for namespaced projects).</p><p>Implementation:</p><ul><li><p>Move the different projects into a specific folder (e.g. <span class="article-inline-snippet">projects</span>) and specify that folder through the <span class="article-inline-snippet">workspaces</span> property in the root <span class="article-inline-snippet">package.json</span> (e.g. <span class="article-inline-snippet">["./projects/*"]</span>).</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces.png" alt="Enabling npm workspaces in package.json"><p class="article-image-footer">Enabling npm workspaces in package.json</p></div></li><li>Remove the <span class="article-inline-snippet">package-lock.json</span> file and the <span class="article-inline-snippet">node_modules</span> folder in each project.</li><li><p>If you have installed local dependencies in any of your projects, you will need to remove them for now, as the relative paths will change when using workspaces. You can later re-install them using the <span class="article-inline-snippet">-w</span> argument (see below). Failing to do so can lead to the following error:</p><div class="article-block-snippet">npm ERR! Cannot set properties of null (setting 'dev')<br><br>npm ERR! A complete log of this run can be found in:<br>npm ERR &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/.../.npm/_logs/2022-05-30T05_57_51_827Z-debug.log<br></div></li><li>Remove the <span class="article-inline-snippet">node_modules</span> folder in the root folder and re-install npm dependencies from the root folder. This will update the <span class="article-inline-snippet">package-lock.json</span> as well, since npm workspaces come with an additional set of dependencies (e.g. <span class="article-inline-snippet">@nodelib/fs.scandir</span>).</li><li><p>Install the common project as a local dependency in all the projects that import code from it, using the common project relative path and the <span class="article-inline-snippet">-w</span> (or <span class="article-inline-snippet">--workspace</span>) argument to specify the target project:</p><div class="article-block-snippet">npm install --save ./projects/weather-common -w weather-client<br>npm install --save ./projects/weather-common -w weather-server</div><p>This will register the local dependency in the root <span class="article-inline-snippet">package.json</span> and <span class="article-inline-snippet">package-lock.json</span>, as well as in the corresponding project's <span class="article-inline-snippet">package.json</span>.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-symbolic-links.png" alt="node.js generated symbolic links, through workspaces"><p class="article-image-footer">node.js generated symbolic links, through workspaces</p></div></li><li><p>Replace all the relative path imports with external dependency imports, using the name of the common project.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-import.png" alt="npm local dependency import, through workspaces"><p class="article-image-footer">npm local dependency import, through workspaces</p></div></li><li><p>To restore the IDE symbols navigation, set the Typescript <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank">paths</a> property:</p><div class="article-block-snippet">{<br>&nbsp;&nbsp;&nbsp;"compilerOptions": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"paths": {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"weather-common": [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"./projects/weather-common/source"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;"extends": "./tsconfig.base.json"<br>}<br></div><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-types-resolution.png" alt="VSCode types definition resolution through Typescript paths"><p class="article-image-footer">VSCode types definition resolution through Typescript paths</p></div></li><li><p>To remove "soft link" npm scripts, replace the <span class="article-inline-snippet">cd</span> instructions in the root <span class="article-inline-snippet">package.json</span> npm scripts with the corresponding <span class="article-inline-snippet">-w</span> or <span class="article-inline-snippet">-ws</span> argument.</p><div><img class="article-image with-footer" src="/images/blog/typescript-monorepo/npm-workspaces-scripts.png" alt="Simplification of root folder npm scripts through npm workspaces"><p class="article-image-footer">Simplification of root folder npm scripts through npm workspaces</p></div></li></ul><h3>Conclusions</h3><p>We have described the "replication" problem that can occur in Typescript monorepos when sharing code between different projects. We have seen how the structure of the distribution folder changes when not adapting Typescript to support such code sharing, and how that can break some relative paths within the application.</p><p>We have also seen different approaches to resolve the "replication" problem, each providing additional advantages for increasing amounts of implementation effort. Quoting the popular reference to feline taxidermy, "there is more than one way to skin a cat". Give them a try and decide which one works better for you. Happy coding!</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/expo-push-notifications">⬅️ Previous</a><div class="title-preview">First-class push notifications for Expo apps</div></span></div><div class="next-link"><span class="link-text"><a href="/blog/express-typed-api">Following ➡️</a><div class="title-preview">Inferring network requests' return type: @express-typed-api</div></span></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">⬇️ Blog</a></div></div></div></div></body></html>