<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>@express-typed-api: inferring the fetch requests' return type | Carles Capellas</title><meta name="description" content="How to use @express-typed-api to declare a type for an express API and automatically infer the corresponding fetch requests' return type" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="@express-typed-api: inferring the fetch requests' return type" data-react-helmet="true"><meta property="og:description" content="How to use @express-typed-api to declare a type for an express API and automatically infer the corresponding fetch requests' return type" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/express-typed-api" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article express-typed-api" lang="en"><div class="article-info"><h2 class="article-title">@express-typed-api: inferring the fetch requests' return type</h2><div class="article-details"><span class="article-date">üìÖ TODO</span><span class="article-duration">üïê -1 mins</span><span class="article-language selected-language">üåé en</span></div></div><div class="article-body"><p>Choosing node.js and Typescript to develop a web app allows for <a href="/blog/typescript-monorepo">reusing the same type definitions</a> in both ends of a web app. Yet, the client/server HTTP requests remain untyped, frustrating our attempts to keep a consistent code base ü§¨ With that idea in mind I wrote <span class="article-inline-snippet">@express-typed-api</span>, a library to help creating a type declaration for an express API so that it can be used to automatically infer the fetch requests' return type from the client side. Here is how to use it.</p><p>Usually, when calling a Web API via <span class="article-inline-snippet">fetch</span>, we either settle with the <span class="article-inline-snippet">any</span> type of the response payload or we explicitly cast it to the type we expect it to be.</p><iframe width="100%" frameborder="0" id="gist-2be8474970323e3c4814e6ee13a629c2" style="height: 325px;"></iframe><p>Explicitly casting the payload's type does provide type safety but it's not ideal: it must be done for each different <span class="article-inline-snippet">fetch</span> call and, more importantly, it is not linked to the actual endpoint's return type. When we change an endpoint's return type, we also need to change the explicit casts accordingly for all of the endpoint's <span class="article-inline-snippet">fetch</span> calls.</p><p>The idea behind <span class="article-inline-snippet">@express-typed-api</span> is generating a type declaration for the express API, with no dependencies on the server side, and in a way that Typescript can tell the return type of the API endpoints based on their path and method. That API type declaration is then provided to a <span class="article-inline-snippet">fetch</span> wrapper function, which uses the request URL and method to automatically infer the function return type. Let's get on with it!</p><p>To better illustrate the explanations in this article I'll be applying the steps on a simple express API with a single get endpoint (i.e. <span class="article-inline-snippet">/api/weather</span>), that receives a city name via query string parameter and returns weather data for the specified city, and the corresponding client side <span class="article-inline-snippet">fetch</span> call. A fairly simple example, yet it involves all the necessary aspects to get automatic inferring going in any other express API.</p><iframe width="100%" frameborder="0" id="gist-2b1c6f55f38d1769cb2b4bb2c773e3af" style="height: 415px;"></iframe><iframe width="100%" frameborder="0" id="gist-2c766ae92d278b2d284a25610e287b29" style="height: 261px;"></iframe><h3>1. API's type declaration</h3><p>The first and obvious step is to define a type for our API, including each endpoint's path and method. A convenient way to generate such type consists in <b>declaring a type</b> containing the endpoints' return type as "properties" and using the endpoints' path/method as keys. This is what we are talking about:</p><iframe width="100%" frameborder="0" id="gist-8c63fc889423183f60c0ee9002e5f4c5" style="height: 349px;"></iframe><p>When using <span class="article-inline-snippet">@express-typed-api</span> we will declare our endpoints using the <span class="article-inline-snippet">EndpointHandler</span> generic type like so. <span class="article-inline-snippet">EndpointHandler</span> is meant to enforce the return type of the endpoints' handler and provides explicit typing for the handlers' express arguments (i.e. <span class="article-inline-snippet">req</span>, <span class="article-inline-snippet">res</span> and <span class="article-inline-snippet">next</span>).</p><iframe width="100%" frameborder="0" id="gist-6eb2b491b2af0ff8ea0eb02122833bbe" style="height: 393px;"></iframe><p>Make sure you create the API type declaration in a <a href="/blog/typescript-monorepo">package/folder that can be imported from both client and server side</a>, and that you install <span class="article-inline-snippet">@express-typed-api/common</span> as a dependency.</p><h3>2. Handlers' return type</h3><p>The second step consists in making Typescript aware of the handlers' return type. Because express handlers send the response data by calling methods on the response object (e.g. <span class="article-inline-snippet">res.json</span>), Typescript is not aware of the handlers' return type (which is usually void). We will need to slightly change the implementation of each handler so that the data is returned as the function result instead.</p><p>A simple way to do so consists in splitting the handler's actual logic and the response object manipulation into two separate functions. One will run the corresponding business logic and return the appropriate data while the other will just call the corresponding response method. This is what it looks like for our sample express API:</p><iframe width="100%" frameborder="0" id="gist-31d7557f3e8a32ce0a3b545de2eb706c" style="height: 569px;"></iframe><p><i>Note that, even though the express response object offers several methods to return data (e.g. <span class="article-inline-snippet">res.send</span>), <span class="article-inline-snippet">@express-typed-api</span> only works with <span class="article-inline-snippet">res.json</span>.</i></p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/handler-payload-return-type.png" alt="Payload part of the endpoint handler's return type"><p class="article-image-footer">Payload part of the endpoint handler's return type</p></div><p>Now Typescript gets access to the handler's return type üëå When using <span class="article-inline-snippet">@express-typed-api</span> it's a good practice to type the endpoints' handler implementation with the types we created for the API type declaration, so we keep the handlers consistent with the type declaration.</p><p>Note that, because we sometimes want to set the response's HTTP status code before sending the payload, we will need our handlers to return an object with two properties: <span class="article-inline-snippet">payload</span> (the type we are actually interested in) and <span class="article-inline-snippet">status</span> (an optional HTTP status code). You can optionally use the <span class="article-inline-snippet">EndpointResponse</span> class to simplify the handlers' return statement.</p><iframe width="100%" frameborder="0" id="gist-f8303dcb64189f7b808b4bb0b0ffb877" style="height: 435px;"></iframe><h3>3. Consistent API's implementation</h3><p>The third step consists in validating that the endpoints' path and method used in the API's implementation match the values used in the API's type declaration. So far we have a type declaration for our API and we are using it in the handler's return type, but we would still run into trouble if we would change the path or method of an endpoint's handler but we forgot to update the corresponding part of the API's type declaration.</p><p>To prevent that from happening we will need to extract the <span class="article-inline-snippet">path</span> and <span class="article-inline-snippet">method</span> values from the express <span class="article-inline-snippet">app.&lt;method&gt;(path, handler)</span> calls and associate them with the corresponding <span class="article-inline-snippet">handler</span> so that Typescript can tell whether the values match the API's type declaration. A convenient way of doing so consists in mimicking the approach we used when declaring the API's type: <b>creating an object</b> containing the endpoints' handlers as properties and using the endpoints' path/method as keys.</p><iframe width="100%" frameborder="0" id="gist-548b3e036f8c4cd62a3991694339507c" style="height: 413px;"></iframe><p>Because we are typing such object with the API's type declaration, we make sure that the API's implementation will always be compliant with its type declaration. Now we only need to use the API representation object to replace the <span class="article-inline-snippet">app.&lt;method&gt;</span> calls: <span class="article-inline-snippet">@express-typed-api/server</span> exports a <span class="article-inline-snippet">publishApi</span> function for that purpose. It receives an express app and an API representation object as parameters and it traverses the representation object properties, calling the necessary methods on the express app with the corresponding method, path and handler. This is what it looks like when used in our sample express API:</p><iframe width="100%" frameborder="0" id="gist-c8d6220e71e27430a2d4e21d8eda6168" style="height: 611px;"></iframe><i><p>Heads up! Having both the API's type declaration and API representation object might feel like an unnecessary code duplication but it is indeed necessary. A couple remarks worth mentioning:</p><ul><li><p>It would be possible to remove the API's type declaration and infer the type from the API representation object instead, but we would then be introducing dependencies on the server side code. Since we want to use the API's type declaration on the client side, that is not an option.</p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/inferred-api-type-declaration.png" alt="API's type declaration inferred from the API representation object"><p class="article-image-footer">API's type declaration inferred from the API representation object</p></div></li><li><p><span class="article-inline-snippet">@express-typed-api</span> exports an <span class="article-inline-snippet">ApiEndpoints</span> helper type to validate the API representation objects. Using it to type the API representation object results in obstructing the Typescript inferring:</p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/obstructed-return-type.png" alt="Typescript inferring obstruction"><p class="article-image-footer">Typescript inferring obstruction</p></div></li></ul></i><h3>4. Fetch requests' return type inferring</h3><p>With the API's type declaration available on the client side the final step is using it to infer the return type of the <span class="article-inline-snippet">fetch</span> calls. <span class="article-inline-snippet">@express-typed-api</span> contains a <span class="article-inline-snippet">typedFetch</span> function, a <span class="article-inline-snippet">fetch</span> wrapper that receives the endpoints' path and method as parameters and, apart from passing them to the actual <span class="article-inline-snippet">fetch</span> call, uses them to cast the response's json <span class="article-inline-snippet">payload</span>.</p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-fetch-usage.png" alt="typedFetch usage"><p class="article-image-footer">typedFetch usage</p></div><p><span class="article-inline-snippet">typedFetch</span> is exported in the <span class="article-inline-snippet">@express-typed-api/client</span> package via a getter function called <span class="article-inline-snippet">getTypedFetch</span>, which is the one that takes the API's type declaration as the type parameter and returns the corresponding instance of <span class="article-inline-snippet">typedFetch</span>. It can be called any number of times but the best practice is to call it once and use the returned function all across the client side code.</p><p>Note also that using query string parameters (and/or express URL parameters) in the request's URL will result in a Typescript error when using <span class="article-inline-snippet">typedFetch</span>. Because the API's type declaration is defined with the endpoints' path instead of the actual requests' URL, i.e. <span class="article-inline-snippet">/api/weather</span> instead of <span class="article-inline-snippet">/api/weather?cityName=xyz</span> (or <span class="article-inline-snippet">/api/weather/:cityName</span> instead of <span class="article-inline-snippet">/api/weather/xyz</span>), Typescript will only accept path arguments that match one of the paths in the API's type declaration.</p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-fetch-invalid-query-string.png" alt="Invalid query string URL parameter"><p class="article-image-footer">Invalid query string URL parameter</p></div><p><span class="article-inline-snippet">typedFetch</span> resolves this issue by taking the query string parameters (or URL parameters) in a separate <span class="article-inline-snippet">query</span> property (or <span class="article-inline-snippet">params</span>) and then building the actual request's URL before passing it down to the underlying <span class="article-inline-snippet">fetch</span> call. Applied to our sample express API fetch request:</p><iframe width="100%" frameborder="0" id="gist-4f25d48d4fe7952395430cb6bc026a9b" style="height: 391px;"></iframe><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-fetch-query-string.png" alt="typedFetch usage with query string parameters"><p class="article-image-footer">typedFetch usage with query string parameters</p></div><p><i>The existence of <span class="article-inline-snippet">getTypedFetch</span> is meant to prevent code duplication in the <span class="article-inline-snippet">typedFetch</span> calls, as using <span class="article-inline-snippet">typedFetch</span> directly would require each call to provide type parameters, duplicating the function's arguments in the function's type parameters.</i></p><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-fetch-explicit-parameters.png" alt="Possible implementation of typedFetch with explicit type parameters"><p class="article-image-footer">Possible implementation of typedFetch with explicit type parameters</p></div><h3>Additional features</h3><p>Finally here are a couple other features that are likely to be needed in modern express APIs and <span class="article-inline-snippet">@express-typed-api</span> does support but, for the sake of simplicity, are not included in the sample express API. Plus a bonus feature to bring type safety to the request's payload as well üí™</p><ul><li><p><b>express middleware</b>. Sometimes we need to run additional middleware before executing an endpoint's handler (e.g. authentication, request parsing, etc.). Let's take the following POST endpoint, for which we want to execute <span class="article-inline-snippet">express.json()</span> before running the actual endpoint handler:</p><iframe width="100%" frameborder="0" id="gist-5709a982dd41b627368a156dc7692382" style="height: 415px;"></iframe><p><span class="article-inline-snippet">@express-typed-api</span> exports a <span class="article-inline-snippet">EndpointHandlerWithMiddleware</span> type for such cases. When declaring an endpoint with this type its implementation will expect an object with two properties: the actual <span class="article-inline-snippet">handler</span> and <span class="article-inline-snippet">middleware</span>, a function that receives the endpoint handler and returns an array with any number of handlers that will be executed in that order:</p><iframe width="100%" frameborder="0" id="gist-3087226f4539e35425e1aee3f43e695b" style="height: 393px;"></iframe><iframe width="100%" frameborder="0" id="gist-0fc0e9513dff375d0227d4ce7327777f" style="height: 677px;"></iframe></li><li><p><b>baseUrl</b>. The API's type declaration does not contain the endpoints' full URL but only relative paths. The <span class="article-inline-snippet">getTypedFetch</span> function accepts an optional <span class="article-inline-snippet">baseUrl</span> parameter that will prepend the provided value to all the <span class="article-inline-snippet">typedFetch</span> requests' URL. Note it can contain any value, not necessarily an absolute URL.</p><iframe width="100%" frameborder="0" id="gist-88fe3f3b9ae0f5b95a201b61d9ec44be" style="height: 281px;"></iframe><p><i>In a similar fashion the server <span class="article-inline-snippet">publishApi</span> method accepts a <span class="article-inline-snippet">pathsPrefix</span> parameter that can be used to remove a common prefix from the API's type declaration, while keeping it in the endpoint's actual path.</i></p></li><li><p><b>Typed request payload</b>. <span class="article-inline-snippet">@express-typed-api</span> allows specifying the type of the requests' payload (i.e. <span class="article-inline-snippet">query</span>, <span class="article-inline-snippet">params</span> and <span class="article-inline-snippet">body</span>) by providing an optional second type parameter to <span class="article-inline-snippet">EndpointHandler</span>, containing any combination of <span class="article-inline-snippet">jsonBody</span>, <span class="article-inline-snippet">params</span> and/or <span class="article-inline-snippet">query</span> types. The types will then be enforced on both client requests and server endpoint handlers:</p><iframe width="100%" frameborder="0" id="gist-4f2bd5cb87b3250730c97b906fd10ffe" style="height: 459px;"></iframe><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-request-payload-server.png" alt="Request query type inferring on the server side"><p class="article-image-footer">Request query type inferring on the server side</p></div><div><img class="article-image with-footer" src="/images/blog/express-typed-api/typed-request-payload-client.png" alt="Request query type inferring on the client side"><p class="article-image-footer">Request query type inferring on the client side</p></div></li></ul><p>And that's pretty much it. There are some more examples in the <a href="https://github.com/capelski/express-typed-api/tree/main/projects/%40sample-express-app" target="_blank">sample repository</a>, and both <a href="https://www.npmjs.com/package/@express-typed-api/server" target="_blank">server</a> and <a href="https://www.npmjs.com/package/@express-typed-api/client" target="_blank">client</a> packages are available on npm, containing the API documentation in the README.md. Give it a try and, hopefully, it will turn out to be useful for you too. Happy coding!</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/typescript-monorepo">‚¨ÖÔ∏è Previous</a><div class="title-preview">Client/Server code sharing in Typescript monorepos</div></span></div><div class="next-link"></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">‚¨áÔ∏è Blog</a></div></div></div></div></body></html>