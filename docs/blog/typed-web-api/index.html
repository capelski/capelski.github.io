<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>@typed-web-api: type safety for fetch requests | Carles Capellas</title><meta name="description" content="How to use @express-typed-api to declare a type for an express API and automatically infer the corresponding network requests' return type" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="@typed-web-api: type safety for fetch requests" data-react-helmet="true"><meta property="og:description" content="How to use @express-typed-api to declare a type for an express API and automatically infer the corresponding network requests' return type" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/typed-web-api" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/typed-web-api/antenna.jpg" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article typed-web-api" lang="en"><div class="article-info"><h2 class="article-title">@typed-web-api: type safety for fetch requests</h2><div class="article-details"><span class="article-date">üìÖ 2024-06-21</span><span class="article-duration">üïê 5 mins</span><span class="article-language selected-language">üåé en</span></div></div><div class="article-body"><p>Writing a web app in Typescript provides type safety in both the client and the server but, what about the communication between the two sides? The payload of network requests remains untyped by default, boycotting our attempts to keep a consistent code base. With that idea in mind I wrote <span class="article-inline-snippet">@typed-web-api</span>, a minimalist approach to adding type safety to fetch requests. Here is how to use it.</p><div><img class="article-image" src="/images/blog/typed-web-api/antenna.jpg" alt="Telecommunications antenna"></div><p>typed-web-api comes in three parts. First we must create a type definition for the web API via <a href="https://www.npmjs.com/package/@typed-web-api/common" target="_blank"><span class="article-inline-snippet">@typed-web-api/common</span></a>. The type definition is a description of all the endpoints, including their path, method and response type. Optionally we can specify their request payload type too.</p><p>This is what the type declaration would look like for a sample web API with three endpoints: <span class="article-inline-snippet">POST /users/login</span>, <span class="article-inline-snippet">GET /users</span>, <span class="article-inline-snippet">GET /users/:userId</span>.</p><iframe width="100%" frameborder="0" id="gist-865f920a3af0ea5125770ff5db898940"></iframe><ul><li>Each endpoint must be listed using the <span class="article-inline-snippet">/path_method</span> format. This opinionated format is a simple convention that allows the library for validating the payload request type depending on the method.</li><li>Splitting the type declarations into subtypes is not necessary, but doing so will make it easier to implement the server endpoints in different controllers (a common practice on the server side).</li></ul><p>Next we can start adding type safety to the client side network requests using <a href="https://www.npmjs.com/package/@typed-web-api/client" target="_blank"><span class="article-inline-snippet">@typed-web-api/client</span></a>. For that we will need to obtain a typed instance of the browser-native <span class="article-inline-snippet">fetch</span> function, by passing the previously created type definition to the <span class="article-inline-snippet">getTypedFetch</span> method. Using the typed fetch function the return type of the network requests will be inferred by Typescript automatically. Using <span class="article-inline-snippet">@typed-web-api/client</span> requires a few minor changes:</p><iframe width="100%" frameborder="0" id="gist-894bee8b6839e70dbeca64107003d88e"></iframe><ul><li>We must obtain the typed fetch function by calling <span class="article-inline-snippet">getTypedFetch</span>, passing the API type declaration as a type parameter. The returned function can be used everywhere in the client app.</li><li>All calls to typed fetch must provide the method along with the path, following the <span class="article-inline-snippet">/path_method</span> format used in the API type definition.</li><li>Additional parameters of fetch calls must be passed to the typed fetch function via the <span class="article-inline-snippet">init</span> parameter.<iframe width="100%" frameborder="0" id="gist-7a974fc01a979ed0fb95e835f8600799"></iframe></li><li>When using query string parameters (i.e. <span class="article-inline-snippet">/users?limit=25</span>) or URL parameters (i.e. <span class="article-inline-snippet">/users/xyz</span>) the values must be passed via the <span class="article-inline-snippet">queryString</span> or <span class="article-inline-snippet">urlParams</span> properties:<iframe width="100%" frameborder="0" id="gist-206c5fbbcff14d23a5b9ebab7ac74b0b"></iframe></li><li>When using typed request payloads, the typed fetch function will expect the request payload to be provided via the corresponding properties.<div><img class="article-image with-footer" src="/images/blog/typed-web-api/request-payload-validation.png" alt="Typescript validation of the request payload in VSCode"><p class="article-image-footer">Typescript validation of the request payload in VSCode</p></div></li></ul><p>Finally, the server side. Here we need to make sure that the web API implementation satisfies the type definition we have generated earlier. This will vary depending on the framework the web API is built with. <span class="article-inline-snippet">@typed-web-api</span> supports two popular frameworks: express and NestJS.</p><p>Consider the following implementation of the sample endpoints described above (I'm using NestJS here but there are examples for both platforms in the <a href="https://github.com/capelski/typed-web-api" target="_blank">official repository</a>). In this code the return type of each endpoint is determined by the type the returned payload happens to have.</p><iframe width="100%" frameborder="0" id="gist-08985890a45287f2f90a3d632cf1ca36"></iframe><p>Using <a href="https://www.npmjs.com/package/@typed-web-api/nestjs" target="_blank"><span class="article-inline-snippet">@typed-web-api/nestjs</span></a> we can guarantee the return types are consistent with the web API type definition just by applying a couple tweaks:</p><iframe width="100%" frameborder="0" id="gist-8a247474814c16c7bf34a9697f5539a0"></iframe><ul><li>Make the controller implement the type definition. By using the generic <span class="article-inline-snippet">ServerEndpoints</span> interface we enforce the controller to implement the endpoints passed in the type parameter, with the appropriate return type. Note that <span class="article-inline-snippet">ServerEndpoints</span> requires the methods' name to contain the full pathname; controller prefixes must be removed (e.g. <span class="article-inline-snippet">'/users'</span>).</li><li>Replace the NestJS method decorators with the almighty <span class="article-inline-snippet">HttpMethod</span> decorator. This decorator is a simple wrapper that calls the corresponding NestJS method decorators based on the method included in function name, passing the pathname as parameter.</li></ul><p>And that's about it. This library is my second attempt at brining type safety to network requests and it benefits from my previous learnings (i.e. <a href="/blog/typescript-monorepo">express-web-api</a>). It is meant to be generic, framework agnostic on the client side, and impose as little changes as possible in both sides of the code. I'm pretty confident with the result but, hey, one always thinks to have done an outstanding job in their limited understanding of the world. Let me know what you think about it if you have a go.</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/typescript-monorepo-ii">‚¨ÖÔ∏è Previous</a><div class="title-preview">Distribution of Typescript shared code without package repositories</div></span></div><div class="next-link"><span class="link-text"><a href="/blog/otf-migrations">Following ‚û°Ô∏è</a><div class="title-preview">Supporting offline data on ever-changing database schemas</div></span></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">‚¨áÔ∏è Blog</a></div></div></div></div></body></html>