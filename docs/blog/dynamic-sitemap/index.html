<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>Maintaining a sitemap based on user generated content | Carles Capellas</title><meta name="description" content="How to maintain a sitemap that includes user generated content" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="Maintaining a sitemap based on user generated content" data-react-helmet="true"><meta property="og:description" content="How to maintain a sitemap that includes user generated content" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/dynamic-sitemap" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/dynamic-sitemap/indexing.jpg" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article dynamic-sitemap" lang="en"><div class="article-info"><h2 class="article-title">Maintaining a sitemap based on user generated content</h2><div class="article-details"><span class="article-date">üìÖ 2025-08-16</span><span class="article-duration">üïê 4 mins</span><span class="article-language selected-language">üåé en</span></div></div><div class="article-body"><p>Generating a sitemap for a web app can be trivial (i.e. using free online tools such as <a href="https://xml-sitemaps.com" target="_blank">xml-sitemaps.com</a>). Things get a bit more complicated when the content we need to index in the sitemap is generated by the users of the web app. Here is how to efficiently build and maintain a dynamic sitemap.</p><div><img class="article-image image-600" src="/images/blog/dynamic-sitemap/indexing.jpg" alt="Abstract representation of a website's sitemap"></div><p>The first intuitive option that might come to mind is to have an endpoint that generates the dynamic sitemap on demand. This might work for small applications, but it becomes too slow when the amount of URLs to index grows beyond a certain limit. Additionally we are consuming database resources that will either drain the web app or generate additional costs.</p><p>The sitemap is meant to be an XML and there is nothing wrong with that. The only particularity about the sitemap containing dynamic content is that we will need to periodically update it. And, because we want to do that without having to deploy new code, we will want that file not to be part of the web app's static assets.</p><p>A good place to store a file that our web app wants to read and modify is a cloud storage bucket (e.g. GCP buckets or S3 buckets). We can either create the file manually or support the scenario when the file is not present via code. Here I'm opting for the first option. Once created, we will read such file every time we need to serve the sitemap (via a <span class="article-inline-snippet">/sitemap.xml</span> endpoint) and return its contents. Here is an example using <a href="https://www.npmjs.com/package/firebase-admin" target="_blank">firebase-admin</a> and <a href="https://www.npmjs.com/package/firebase-functions" target="_blank">firebase-functions</a>.</p><div><img class="article-image with-footer" src="/images/blog/dynamic-sitemap/gcp-storage-bucket.png" alt="Storage bucket view in Google Cloud Platform"><p class="article-image-footer">Storage bucket view in Google Cloud Platform</p></div><iframe width="100%" frameborder="0" id="gist-22fc692aa301fad285e013b3927a24cc"></iframe><p>The challenging part in this approach is deciding when and how to update the file contents. It can be tempting to update the file in real time every time users create or delete a resource, so the sitemap is always up-to-date. Chances are however that users will create content concurrently and we don't want to risk parallel requests accessing the file and overwriting the contents at the same time. It would be more cautious to allow the sitemap to go a few hours out-of-date and to update it periodically via a scheduled job.</p><p>Another consideration is whether the job should recompute the entire file content or make incremental updates to the existing file content. While the first option sounds simpler it will also consume more resources. If we are using a cloud-hosted database (e.g. Firestore) this will substantially increase the costs of running the web app (see this <a href="https://stackoverflow.com/questions/66066333/firebase-functions-hosting-rewrite-to-dynamically-generate-sitemap-xml-with-mor" target="_blank">Stack Overflow post</a>). Incremental updates to the file are a bit more tricky but they will pay off. In essence we need to:</p><ul><li><b>Flag new resources</b> after they are created so the job can identify the new URLs that must be <b>added</b> to the sitemap.</li><li><b>Track resource deletions</b> so the job can identify the URLs that must be <b>removed</b> from the sitemap.</li></ul><p>The job will then obtain the list of URLs that must be added/removed, read the contents of the file, update it with the corresponding URL changes and write the file back to the storage bucket. The implementation will depend largely on the server architecture. Here is an example using Firestore and Firebase functions assuming that:</p><ul><li>Each resource contains a property (i.e. <span class="article-inline-snippet">created</span>) with its creation timestamp. To find out which resources need to be added to the sitemap we will filter on that property for values between now and the last time the job run.</li><li>We are using the <span class="article-inline-snippet">onDocumentDeleted</span> Firebase trigger to add the corresponding document ID to another Firestore collection (i.e. <span class="article-inline-snippet">sitemapDeletions</span>) every time a resource is deleted.</li><li>The URLs can be built from each resource ID without any logic. If we wanted to support different types of dynamic URLs, we would have to store additional metadata in the <span class="article-inline-snippet">sitemapDeletions</span> collection.</li><li>We have two functions (i.e. <span class="article-inline-snippet">getNewResourceIds</span> and <span class="article-inline-snippet">getDeletedResourceIds</span>) that retrieve the complete list of IDs that must be added/removed to the sitemap. Such functions crawl the Firestore collections and build a plain list of strings.</li></ul><iframe width="100%" frameborder="0" id="gist-4762368d88693b8991df334e39482de2"></iframe><p><i>Similarly to the <span class="article-inline-snippet">sitemapDeletions</span> collection, we could define a <span class="article-inline-snippet">sitemapAdditions</span> collection and use the <span class="article-inline-snippet">onDocumentCreated</span> trigger to add URLs every time a new resource is created. Note however that this would mean additional write operations to remove the IDs from the collection after the job has updated the file. Symmetric approach but higher costs.</i></p><p>Once deployed the job will run every midnight, looking for changes in resources and updating the sitemap accordingly when needed. Happy coding!</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/react-ssr">‚¨ÖÔ∏è Previous</a><div class="title-preview">React server side rendering powered by Webpack</div></span></div><div class="next-link"></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">‚¨áÔ∏è Blog</a></div></div></div></div></body></html>