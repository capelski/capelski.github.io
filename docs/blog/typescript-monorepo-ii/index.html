<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>Distribution of Typescript shared code without package repositories | Carles Capellas</title><meta name="description" content="Distributing shared Typescript code to production environments without package repositories" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="Distribution of Typescript shared code without package repositories" data-react-helmet="true"><meta property="og:description" content="Distributing shared Typescript code to production environments without package repositories" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/typescript-monorepo-ii" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/typescript-monorepo-ii/distribution.jpg" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article typescript-monorepo-ii" lang="en"><div class="article-info"><h2 class="article-title">Distribution of Typescript shared code without package repositories</h2><div class="article-details"><span class="article-date">📅 2024-06-07</span><span class="article-duration">🕐 5 mins</span><span class="article-language selected-language">🌎 en</span></div></div><div class="article-body"><p>A couple years ago I wrote a piece about <a href="/blog/typescript-monorepo">sharing code in Typescript monorepos</a>, focusing mainly on npm workspaces, and I left out an important aspect of the software development lifecycle: shipping the compiled files to production environments. Because that is such a fundamental part of software development, I'll be addressing it in this second piece of writing.</p><div><img class="article-image" src="/images/blog/typescript-monorepo-ii/distribution.jpg" alt="Package distribution representation"></div><p>Having successfully extracted the duplicate code into a separate directory/npm project (covered in <a href="/blog/typescript-monorepo">sharing code in Typescript monorepos</a>), the task at hand is to decide how the shared code and its external dependencies will make their way to production environments. Let's consider two different solutions: one based on <b>relative path imports</b> and another based on <b>npm dependencies</b>.</p><p><i>Note that the distribution issue is mostly a server side concern since client apps are usually bundled into static assets that include both external dependencies and code imported from outside the project.</i></p><p>To make the explanations more tangible, let's introduce a simple <a href="https://github.com/capelski/typescript-monorepo" target="_blank">monorepo example</a>. For the sake of simplicity the example code has no actual functionality, just one duplicate function (<span class="article-inline-snippet">getId</span>) that relies on one external dependency (<span class="article-inline-snippet">nanoid</span>). Here is the monorepo structure:</p><div class="article-block-snippet">root<br>📂&nbsp;client<br>|&nbsp;&nbsp;📂&nbsp;source<br>|&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;index.html<br>|&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;index.tsx<br>|&nbsp;&nbsp;📝&nbsp;package.json<br>|&nbsp;&nbsp;📝&nbsp;tsconfig.json<br>|&nbsp;&nbsp;📝&nbsp;webpack.config.js<br>📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;📂&nbsp;public<br>&nbsp;&nbsp;&nbsp;📂&nbsp;source<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;main.ts<br>&nbsp;&nbsp;&nbsp;📝&nbsp;Dockerfile<br>&nbsp;&nbsp;&nbsp;📝&nbsp;package.json<br>&nbsp;&nbsp;&nbsp;📝&nbsp;tsconfig.json<br></div><p>The server side code:</p><iframe width="100%" frameborder="0" id="gist-c1687116d228e99ffb82b4e3e3a042cb"></iframe><p>And the client side code:</p><iframe width="100%" frameborder="0" id="gist-3049496ceedf7650196bdc6adaa77c31"></iframe><h3>Relative path imports</h3><p>When importing shared code via relative path imports, Typescript will include the shared code into the project's compiled files. Distribution problem solved! But there's a caveat: importing code from outside the project directory via relative paths will impact the way Typescript compiles the files.</p><p>Because we are now importing code from outside the project's <a href="https://www.typescriptlang.org/tsconfig#rootDir" target="_blank"><span class="article-inline-snippet">rootDir</span></a>, Typescript will need to create additional directories inside the compiled files directory. In our example the directory structure will change from</p><div class="article-block-snippet">root<br>📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;📂&nbsp;dist<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📝&nbsp;main.js<br>&nbsp;&nbsp;&nbsp;📂&nbsp;source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;main.ts<br></div><p>to:</p><div class="article-block-snippet">root<br>📂&nbsp;shared<br>|&nbsp;&nbsp;📝&nbsp;index.ts<br>📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;📂&nbsp;dist<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;server<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;source<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;main.js<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;📂&nbsp;shared<br>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;index.js<br>&nbsp;&nbsp;&nbsp;📂&nbsp;source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;📝&nbsp;main.ts<br></div><p><i>Depending on the Typescript version you use, importing code from outside the project directory might result in the following error. To fix it, simply change the <span class="article-inline-snippet">rootDir</span> property to the path of the directory that contains all projects (usually, <span class="article-inline-snippet">".."</span>).<div class="article-block-snippet">source/main.ts:3:23 - error TS6059: File '/typescript-monorepo/shared/index.ts' is not under 'rootDir' '/typescript-monorepo/server/source'. 'rootDir' is expected to contain all source files.<br><br>import { getId } from "../../shared";</div></i></p><p>This consequence comes from the fact that Typescript doesn't change import paths during compilation. Therefore the only way to guarantee the paths are still correct after compilation is to replicate the same directory structure. The new directory structure is not necessarily a deal breaker, but it could be when using non-import relative paths (e.g. <span class="article-inline-snippet">resolve(__dirname, "..", "public")</span>).</p><p>A simple solution is to make the non-imports paths relative to the distribution directory. In our example: <span class="article-inline-snippet">resolve(__dirname, "..", "..", "..", "public")</span>. Another solution, for cases where development tools are used to run the project without compiling (i.e. <span class="article-inline-snippet">ts-node</span>), would be to set those paths depending on the execution mode.</p><p>And what about the external dependencies of the shared code? Well, since the shared code is not an npm project, it can't manage its own dependencies. Each project that imports from it is responsible for installing any dependencies the shared code might need. It means having the same dependencies declared across different <span class="article-inline-snippet">package.json</span> files but, hey, they were already there before the code extraction, so it's not a big deal. If you want to manage the external dependencies of the shared code from a single source, then the <b>npm dependencies</b> approach will work better for you.</p><p>Summary:</p><ul><li>👍 The compiled files include the shared code.</li><li>👎 Might break non-import relative paths.</li><li>👎 Duplicate dependencies across different package.json files.</li></ul><p>Changes: <a href="https://github.com/capelski/typescript-monorepo/compare/main...relative-path-imports" target="_blank">https://github.com/capelski/typescript-monorepo/compare/main...relative-path-imports</a></p><iframe width="100%" frameborder="0" id="gist-f29477fe4c52e48b917e23d053a83197"></iframe><iframe width="100%" frameborder="0" id="gist-68d8ed0f32ead27c7a082d477b715abe"></iframe><h3>npm dependencies</h3><p>When importing shared code via npm dependencies (local or public), the shared code becomes an independent npm project, so it can manage its own dependencies. One problem solved! Now, what about the distribution of the compiled files?</p><p>When opting for public dependencies, the shared code will be provisioned via the dependencies installation step (executed either directly on the production environments or via Docker image). Note however that public dependencies involve additional overhead (e.g. publishing the dependency to a package repository). For the sake of simplicity, let's consider local dependencies this time.</p><p>When opting for local dependencies, the shared code will no longer be provisioned via the dependencies installation step. This happens because local dependencies are just a symbolic link inside the <span class="article-inline-snippet">node_modules</span> directory, which rely on the shared code being present in the workspace. Because the shared code will not be present by default in the production environment, we will need to provide it separately.</p><p>This is what happens in our example when we try to run the Dockerized application after having extracted the duplicate code into an npm local dependency:</p><div class="article-block-snippet">&gt; docker run -p 3000:3000 server<br><br><br>&gt; server@1.0.0 start<br>&gt; node dist/main.js<br><br>node:internal/modules/cjs/loader:1042<br> throw err;<br> ^<br><br>Error: Cannot find module 'shared'<br>Require stack:<br>- /usr/src/app/dist/main.js<br>  at Module._resolveFilename (node:internal/modules/cjs/loader:1039:15)<br>  at Module._load (node:internal/modules/cjs/loader:885:27)<br>  at Module.require (node:internal/modules/cjs/loader:1105:19)<br>  at require (node:internal/modules/cjs/helpers:103:18)<br>  at Object.&lt;anonymous&gt; (/usr/src/app/dist/main.js:8:18)<br>  at Module._compile (node:internal/modules/cjs/loader:1218:14)<br>  at Module._extensions..js (node:internal/modules/cjs/loader:1272:10)<br>  at Module.load (node:internal/modules/cjs/loader:1081:32)<br>  at Module._load (node:internal/modules/cjs/loader:922:12)<br>  at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) {<br> code: 'MODULE_NOT_FOUND',<br> requireStack: [ '/usr/src/app/dist/main.js' ]<br>}</div><p>To fix this problem we will need to explicitly provision the shared code npm project, independently from the external dependencies installation. For Dockerizied apps, one way to do so consists in including the npm project in the Docker image of the projects that import it, using the same relative path.</p><p>In our example, this means changing the Docker build command to start from the parent directory (as it will now need access to both the server and shared projects' directory) and turning the Dockerfile (simplified) from</p><div class="article-block-snippet">FROM node:18.13.0-alpine<br><br>WORKDIR /usr/src/app<br>COPY . .<br>RUN npm ci --omit=dev<br><br>EXPOSE 3000<br>CMD npm start<br></div>to<div class="article-block-snippet">FROM node:18.13.0-alpine<br><br># Copy shared code and install its dependencies<br>WORKDIR /usr/src/shared<br>COPY ./shared .<br>RUN npm ci --omit=dev<br><br>WORKDIR /usr/src/app<br>COPY ./server . # The path must now be relative to the parent directory<br>RUN npm ci --omit=dev<br><br>EXPOSE 3000<br>CMD npm start<br></div><p>Summary:</p><ul><li>👍 The shared code dependencies are managed in a single package.json file.</li><li>👎 Additional effort required to distribute the shared code.</li></ul><p>Changes: <a href="https://github.com/capelski/typescript-monorepo/compare/main...npm-dependencies" target="_blank">https://github.com/capelski/typescript-monorepo/compare/main...npm-dependencies</a></p><iframe width="100%" frameborder="0" id="gist-92a4a8fa35cdca982458385a8ec87986"></iframe><iframe width="100%" frameborder="0" id="gist-7252ebbb9c5885506bcf51191fe33ae5"></iframe><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/web-rtc">⬅️ Previous</a><div class="title-preview">A comprehensive WebRTC walkthrough</div></span></div><div class="next-link"><span class="link-text"><a href="/blog/typed-web-api">Following ➡️</a><div class="title-preview">@typed-web-api: type safety for fetch requests</div></span></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">⬇️ Blog</a></div></div></div></div></body></html>