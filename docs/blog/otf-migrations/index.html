<!DOCTYPE html><html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="Carles Capellas"><meta name="theme-color" content="#000000"><meta name="robots" content="index, follow"><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js",{scope:"/"})}))</script><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><script defer="defer" src="/main.js"></script><link href="/main.css" rel="stylesheet"><title>Supporting offline data on ever-changing database schemas | Carles Capellas</title><meta name="description" content="How to support offline data on ever-changing database schemas" data-react-helmet="true"><meta property="og:site_name" content="Carles Capellas" data-react-helmet="true"><meta property="og:type" content="article" data-react-helmet="true"><meta property="og:title" content="Supporting offline data on ever-changing database schemas" data-react-helmet="true"><meta property="og:description" content="How to support offline data on ever-changing database schemas" data-react-helmet="true"><meta property="og:url" content="https://capelski.github.io/blog/otf-migrations" data-react-helmet="true"><meta property="og:image" content="https://capelski.github.io/images/blog/otf-migrations/hard-drive.jpg" data-react-helmet="true"></head><body><noscript><h1>Carles Capellas</h1><p>JavaScript is required to load my page</p></noscript><div id="app-placeholder"><div class="app-container"><div class="article-container"><div class="section-viewport"><div class="section-content"><div class="article otf-migrations" lang="en"><div class="article-info"><h2 class="article-title">Supporting offline data on ever-changing database schemas</h2><div class="article-details"><span class="article-date">üìÖ 2024-08-07</span><span class="article-duration">üïê 6 mins</span><span class="article-language selected-language">üåé en</span></div></div><div class="article-body"><p>Apps that allow users to generate data while being offline (Trello, for example) generally provide a better user experience. They must resolve a challenge however: because the database schema naturally changes as the app evolves, the server must support incoming data generated on an old schema version. How? Here is one way of doing it.</p><div><img class="article-image" src="/images/blog/otf-migrations/hard-drive.jpg" alt="Hard disk drive"></div><h3>The challenge</h3><p>At <a href="https://peekvision.org/" target="_blank">Peek Vision</a>, the company I work for, we collect eye health data from patients in rural areas with little or no connectivity. This means that devices must be able to collect data while being offline. And devices stay offline for surprisingly long periods of time: usually several days, often a couple weeks and sometimes even months.</p><p>When devices finally go online they send the data they have collected to the server. Which, like most web APIs, performs validations on it: if the incoming data doesn't have the expected format it will be rejected. Nothing unusual. But turns out that, as the app evolves and new software is released, the expected formats can change, potentially rendering invalid data collected on offline devices running on a previous software release.</p><p>Having hundreds of active users there will hardly be any moments where all devices have synced their data. Therefore we needed a mechanism to allow data generated on a previous release to be accepted by the server running on a newer release. We called that mechanism on-the-fly migrations, or OTF migrations for short.</p><p>The idea behind OTF migrations is quite straightforward: intercepting arriving data before validating it and applying required migrations if necessary. OTF migrations can be implemented at either global level or endpoint level. Personally, I find it cleaner to go for the endpoint level, but both approaches are equally valid:</p><ul><li>A global interceptor defines a single entry point for migrations, making endpoints migrations agnostic, but it requires checking the request method (we will only want to migrate request that have a body) and evaluating the requests' URL to decide which migrations need to run on a given payload.</li><li>Endpoint-level interceptors split the migrations into several entry points, making endpoints migrations aware, but it produces simpler interceptors code.</li></ul><h3>Hands on</h3><p>Consider a Trello-like app that allows creating notes in offline devices. The notes contains just a text field and the server has an endpoint that receives one note at a time, to which offline notes are posted when devices go online. This is what a NestJS implementation could look like, plus a sample client call:</p><iframe width="100%" frameborder="0" id="gist-989f37b845ea0ee16907b021c5413eb3"></iframe><p><i>The implementation will obviously vary depending on the server framework. Here I'm using NestJS but the core idea is applicable to any framework.</i></p><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"text\": \"Write that medium article I've been postponing\"}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"text":"Write that medium article I've been postponing"}</div><p>So far so good. Now it's time to introduce some breaking changes üí£ Let's assume that, at some point, we decide the notes will have a title and a description instead of a single text field.</p><p>We will change the database schema accordingly and write a script to migrate the existing data in the database. We will update the app as well to post the notes with a title and an optional description. Not a trivial change, but simple enough:</p><iframe width="100%" frameborder="0" id="gist-e7ea8df7d127fceccd36c7bff9f56899"></iframe><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"title\": \"Enough excuses\", \"description\": \"Write that medium article I've been postponing\"}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"title": "Enough excuses", "description": "Write that medium article I've been postponing"}</div><p>Note however that some devices might have generated offline data using the old schema (i.e. a note with a single text field), and they might not have synced the data by the time we deploy the changes to the live environment. In those cases the incoming notes will result in a validation error:</p><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"text\": \"Write that medium article I've been postponing\"}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"message":["title must be a string"],"error":"Bad Request","statusCode":400}</div><p>Here is where OTF migrations will come handy. In a nutshell, we want to manipulate the request body before the <span class="article-inline-snippet">class-validator</span> logic kicks in. There are several ways to achieve this in NestJS and here I'll use interceptors.</p><p><i>We could use middleware as well, but I find that slightly more obscure for this use case, as the Nest middleware must be applied to modules, whereas interceptors can be applied to specific endpoints.</i></p><p>An interceptor class must implement the <span class="article-inline-snippet">NestInterceptor</span> interface, and it can then be applied to any endpoint via the <span class="article-inline-snippet">UseInterceptors</span> decorator. Here is what our interceptor could look like and how to use it in the note creation endpoint:</p><iframe width="100%" frameborder="0" id="gist-e3620e90cc699cb82fc6a5e89b8c76a9"></iframe><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"text\": \"Write that medium article I've been postponing\"}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"title":"Write that medium article I've been postponing"}</div><p>Simple yet effective: the notes generated in the old schema version will now be automatically migrated and accepted by the class validators üíÉ</p><p>This implementation is not very scalable however. Chances are that we will need more OTF migrations as the app evolves, having to add more <span class="article-inline-snippet">UseInterceptors</span> decorators, in the correct order, to each endpoint that requires OTF migrations.</p><p>To prevent that we can group the different OTF migrations that must be applied to each model in a single interceptor. An elegant way of doing so is to split the interceptor from the migrations themselves, turning each migration into a simple function that will be invoked from the interceptor. Beautiful üíò</p><iframe width="100%" frameborder="0" id="gist-f4cc6682e06b1f139c1f5d23d2b241f9"></iframe><p>Another challenge of this implementation is that migrations will always run, even for data generated in the current schema version. This might backfire at us. Imagine we decide to add a boolean <span class="article-inline-snippet">text</span> property; the OTF migration will incorrectly replace the notes title. We need to prevent that from happening. We can determine which OTF migrations need to be applied to an incoming piece of data by:</p><ul><li>Including the current schema version to each entity generated on the app. The schema can be sent either as a separate parameter or as part of the entity itself. In this article, I'll use the latter.</li><li>Specifying a target schema version for each migration.</li><li>Comparing the schema version of the incoming data with the target schema of each migration.</li></ul><iframe width="100%" frameborder="0" id="gist-9b62e3a409158d3896d48fe81b704265"></iframe><p><i>Note that now we no longer need to check whether <span class="article-inline-snippet">body.text</span> exists; the schema condition ensures the incoming data will have a text property.</i></p><p>From now on the schema property included in the data will determine which OTF migrations are executed. Once the migrations have been applied, technically, we no longer need the schema property. We can either:</p><ul><li>Delete the property, so it doesn't end up in the database. Note we need to delete the property once all the potential OTF migrations have been applied.</li><li>Keep the property, as it might be useful to migrate existing data in the database. In this case we need each migration to set the schema property on the entity to the migration's target schema.</li></ul><p>Adding the aforementioned <span class="article-inline-snippet">text</span> property no longer messes with the incoming data:</p><iframe width="100%" frameborder="0" id="gist-c4a2f69ab305139b08393313d9b6442b"></iframe><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"text\": \"Write that medium article I've been postponing\"}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"title":"Write that medium article I've been postponing", "schema": 2, "text": true}</div><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"title\": \"Enough excuses\", \"description\": \"Write that medium article I've been postponing\", \"schema\": 1}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"title": "Enough excuses", "description": "Write that medium article I've been postponing", "schema": 2, "text": true}</div><div class="article-block-snippet">$ curl \<br>‚ÄÉ--header "Content-Type: application/json" \<br>‚ÄÉ--request POST \<br>‚ÄÉ--data "{\"title\": \"Enough excuses\", \"description\": \"Write that medium article I've been postponing\", "text": false, \"schema\": 2}" \<br>‚ÄÉhttp://localhost:3000/notes<br><br>{"title": "Enough excuses", "description": "Write that medium article I've been postponing", "text": false, "schema": 2}</div><p>Finally we can slightly improve the interceptors by automatically sorting the migrations based on the target schema and extracting the common behavior to a base class. This is not really necessary but, hey, we developers cannot help ourselves from refactoring, can we?</p><iframe width="100%" frameborder="0" id="gist-8acb318477b5758996a971870465f351"></iframe><p>And that's it. A well tested OTF migrations architecture for NestJS/express servers. See this <a href="https://github.com/capelski/otf-migrations" target="_blank">working demo repository</a> for more details. Credit goes to Richard Evans, our lead developer, who will retire in September but whose contributions will remain in the company's legacy for years to come üçª</p><h3 class="posts-timeline">Posts timeline</h3><div class="article-links"><div class="previous-link"><span class="link-text"><a href="/blog/typed-web-api">‚¨ÖÔ∏è Previous</a><div class="title-preview">@typed-web-api: type safety for fetch requests</div></span></div><div class="next-link"></div></div></div></div></div></div><div class="section-links"><a aria-current="page" class="link active" href="/blog">‚¨áÔ∏è Blog</a></div></div></div></div></body></html>